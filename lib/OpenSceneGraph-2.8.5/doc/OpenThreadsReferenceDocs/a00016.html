<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenThreads: OpenThreads::Thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="a00029.html">OpenThreads</a>      </li>
      <li><a class="el" href="a00016.html">OpenThreads::Thread</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>OpenThreads::Thread Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="OpenThreads::Thread" -->
<p>This class provides an object-oriented thread interface.  
<a href="#_details">More...</a></p>

<p><a href="a00063.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a">ThreadPriority</a> { <br/>
&nbsp;&nbsp;<a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8aaca626a35b29da730ae163f8667276485">THREAD_PRIORITY_MAX</a>, 
<a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8aa9eea97f93edb239ad8a345fff4738515">THREAD_PRIORITY_HIGH</a>, 
<a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8aa602b81da7585b77b237381fbc95e2982">THREAD_PRIORITY_NOMINAL</a>, 
<a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8aa648c3a9cf6ccc3564c50df7150ceee6c">THREAD_PRIORITY_LOW</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8aaa650066dc1919eb45e2ff21cfb95fa41">THREAD_PRIORITY_MIN</a>, 
<a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8aa04fd8e4a307e9ba44a526c8f092e5c5a">THREAD_PRIORITY_DEFAULT</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumerated Type for thread priority. </p>
 <a href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579b">ThreadPolicy</a> { <a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579ba0ab427d0611058159c030233a9f7b0e6">THREAD_SCHEDULE_FIFO</a>, 
<a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579bae5a4ca7586e8941a6eaa0f6a760fe8e0">THREAD_SCHEDULE_ROUND_ROBIN</a>, 
<a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579baed3ce4d10db48030ec2a2ae2696baaaf">THREAD_SCHEDULE_TIME_SHARE</a>, 
<a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579ba8d77c442e1a8559d99c351b4283387c5">THREAD_SCHEDULE_DEFAULT</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumerated Type for thread scheduling policy. </p>
 <a href="a00016.html#a40f88ee2a59fb412061db2d7970e579b">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a6bc90253917b28b50c2647203dd2ae5a">Thread</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a6bc90253917b28b50c2647203dd2ae5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#ae2926edc9f776621253c389d58bd695b">~Thread</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#ae2926edc9f776621253c389d58bd695b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a62b30f90878282381a5fc13e7ce6b3a1">getThreadId</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a unique thread id.  <a href="#a62b30f90878282381a5fc13e7ce6b3a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#af607d54c7c72922687e7ed0c6ff3bc09">getProcessId</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the thread's process id.  <a href="#af607d54c7c72922687e7ed0c6ff3bc09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#ae52eaf0475bc84991cc9f96d64783b84">start</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the thread.  <a href="#ae52eaf0475bc84991cc9f96d64783b84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a856e61d61aec17cef517a24e542b8778">startThread</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a989e6a1153973a7d68c423892f9022c5">testCancel</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test the cancel state of the thread.  <a href="#a989e6a1153973a7d68c423892f9022c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc">cancel</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel the thread.  <a href="#abe4a808c444f7548520680e6bfa1dbfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a2cc88b654a3ad4a5819def841cdf4614">setSchedulePriority</a> (<a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a">ThreadPriority</a> priority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the thread's schedule priority.  <a href="#a2cc88b654a3ad4a5819def841cdf4614"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a9243e10f7dcad7b5f478c8af439fb276">getSchedulePriority</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the thread's schedule priority (if able).  <a href="#a9243e10f7dcad7b5f478c8af439fb276"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a69641fb3ee2b57d3180fbc14608447f8">setSchedulePolicy</a> (<a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579b">ThreadPolicy</a> policy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the thread's scheduling policy (if able).  <a href="#a69641fb3ee2b57d3180fbc14608447f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#aea5d04ad5853479e6e078b46a0e98d50">getSchedulePolicy</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the thread's policy (if able).  <a href="#aea5d04ad5853479e6e078b46a0e98d50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a3eb85b3440b099ea8447e6f8755aa830">setStackSize</a> (size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the thread's desired stack size (in bytes).  <a href="#a3eb85b3440b099ea8447e6f8755aa830"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#ab931488a56f81dfbdfe176ff86eacbc3">getStackSize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the thread's desired stack size.  <a href="#ab931488a56f81dfbdfe176ff86eacbc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a4e8df0a910c9929182fb7fb31f57ce4f">printSchedulingInfo</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the thread's scheduling information to stdout.  <a href="#a4e8df0a910c9929182fb7fb31f57ce4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#ac2e01b8769557110f11f6fbfa5b5aba6">detach</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach the thread from the calling process.  <a href="#ac2e01b8769557110f11f6fbfa5b5aba6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#ab451f90cde2c3f87f8dc2c9a5faad979">join</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Join the calling process with the thread.  <a href="#ab451f90cde2c3f87f8dc2c9a5faad979"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a71634250a1e70b4396400cfa011dff18">setCancelModeDisable</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable thread cancelation altogether.  <a href="#a71634250a1e70b4396400cfa011dff18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a270bb39ee3c65b87d4016809e32de737">setCancelModeAsynchronous</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark the thread to cancel aysncronously on <a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc" title="Cancel the thread.">Thread::cancel()</a>.  <a href="#a270bb39ee3c65b87d4016809e32de737"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#afc485fe54a15b8a445725f838193158d">setCancelModeDeferred</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark the thread to cancel at the earliest convenience on <a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc" title="Cancel the thread.">Thread::cancel()</a> (This is the default).  <a href="#afc485fe54a15b8a445725f838193158d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a96d8f223f11c3a71f1785a2112051633">isRunning</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the thread's running status.  <a href="#a96d8f223f11c3a71f1785a2112051633"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#afb802d904cca9e3206149a9efe1f83e4">run</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread's run method.  <a href="#afb802d904cca9e3206149a9efe1f83e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a3bebbad70a956a47e30737298becc51f">cancelCleanup</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread's cancel cleanup routine, called upon <a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc" title="Cancel the thread.">cancel()</a>, after the cancelation has taken place, but before the thread exits completely.  <a href="#a3bebbad70a956a47e30737298becc51f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a27e0b385c49d1f57e2ecb8363d3641d1">getImplementation</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a91efa532982ea5a89a485a802617b2e2">setProcessorAffinity</a> (unsigned int cpunum)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread's processor affinity method.  <a href="#a91efa532982ea5a89a485a802617b2e2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a1369402cdf698506e1304723cb08057d">SetConcurrency</a> (int concurrencyLevel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the concurrency level for a running application.  <a href="#a1369402cdf698506e1304723cb08057d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#adee75f3a133fc285b25e723cfa2ed6eb">GetConcurrency</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the concurrency level for a running application.  <a href="#adee75f3a133fc285b25e723cfa2ed6eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00016.html">Thread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a1760ce9beb19bcf222ab8ac86b6c58d6">CurrentThread</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pointer to the current running thread.  <a href="#a1760ce9beb19bcf222ab8ac86b6c58d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#af988ef894b393b5dbc250c21cea0ae2d">Init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize Threading in a program.  <a href="#af988ef894b393b5dbc250c21cea0ae2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a76a5bba0a8865c880f984c6df383eb7d">YieldCurrentThread</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Yield the processor.  <a href="#a76a5bba0a8865c880f984c6df383eb7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a">ThreadPriority</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#aff79998cc4b7360d3d80120c8fb88b61">GetMasterPriority</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method will return the ThreadPriority of the master process.  <a href="#aff79998cc4b7360d3d80120c8fb88b61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a19f97253ae90bb5e137cf96d82023220">microSleep</a> (unsigned int microsec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">microSleep method, equivilant to the posix usleep(microsec).  <a href="#a19f97253ae90bb5e137cf96d82023220"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#a2a1b7d1a2228897da066a0bd92589ba9">ThreadPrivateActions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Private Actions class is allowed to operate on private data.  <a href="#a2a1b7d1a2228897da066a0bd92589ba9"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides an object-oriented thread interface. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a40f88ee2a59fb412061db2d7970e579b"></a><!-- doxytag: member="OpenThreads::Thread::ThreadPolicy" ref="a40f88ee2a59fb412061db2d7970e579b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579b">OpenThreads::Thread::ThreadPolicy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumerated Type for thread scheduling policy. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a40f88ee2a59fb412061db2d7970e579ba0ab427d0611058159c030233a9f7b0e6"></a><!-- doxytag: member="THREAD_SCHEDULE_FIFO" ref="a40f88ee2a59fb412061db2d7970e579ba0ab427d0611058159c030233a9f7b0e6" args="" -->THREAD_SCHEDULE_FIFO</em>&nbsp;</td><td>
<p>First in, First out scheduling. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40f88ee2a59fb412061db2d7970e579bae5a4ca7586e8941a6eaa0f6a760fe8e0"></a><!-- doxytag: member="THREAD_SCHEDULE_ROUND_ROBIN" ref="a40f88ee2a59fb412061db2d7970e579bae5a4ca7586e8941a6eaa0f6a760fe8e0" args="" -->THREAD_SCHEDULE_ROUND_ROBIN</em>&nbsp;</td><td>
<p>Round-robin scheduling (LINUX_DEFAULT). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40f88ee2a59fb412061db2d7970e579baed3ce4d10db48030ec2a2ae2696baaaf"></a><!-- doxytag: member="THREAD_SCHEDULE_TIME_SHARE" ref="a40f88ee2a59fb412061db2d7970e579baed3ce4d10db48030ec2a2ae2696baaaf" args="" -->THREAD_SCHEDULE_TIME_SHARE</em>&nbsp;</td><td>
<p>Time-share scheduling (IRIX DEFAULT). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40f88ee2a59fb412061db2d7970e579ba8d77c442e1a8559d99c351b4283387c5"></a><!-- doxytag: member="THREAD_SCHEDULE_DEFAULT" ref="a40f88ee2a59fb412061db2d7970e579ba8d77c442e1a8559d99c351b4283387c5" args="" -->THREAD_SCHEDULE_DEFAULT</em>&nbsp;</td><td>
<p>Default scheduling. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f57fed98f49a387ae1dd3e0cc185e8a"></a><!-- doxytag: member="OpenThreads::Thread::ThreadPriority" ref="a1f57fed98f49a387ae1dd3e0cc185e8a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a">OpenThreads::Thread::ThreadPriority</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumerated Type for thread priority. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a1f57fed98f49a387ae1dd3e0cc185e8aaca626a35b29da730ae163f8667276485"></a><!-- doxytag: member="THREAD_PRIORITY_MAX" ref="a1f57fed98f49a387ae1dd3e0cc185e8aaca626a35b29da730ae163f8667276485" args="" -->THREAD_PRIORITY_MAX</em>&nbsp;</td><td>
<p>The maximum possible priority. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1f57fed98f49a387ae1dd3e0cc185e8aa9eea97f93edb239ad8a345fff4738515"></a><!-- doxytag: member="THREAD_PRIORITY_HIGH" ref="a1f57fed98f49a387ae1dd3e0cc185e8aa9eea97f93edb239ad8a345fff4738515" args="" -->THREAD_PRIORITY_HIGH</em>&nbsp;</td><td>
<p>A high (but not max) setting. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1f57fed98f49a387ae1dd3e0cc185e8aa602b81da7585b77b237381fbc95e2982"></a><!-- doxytag: member="THREAD_PRIORITY_NOMINAL" ref="a1f57fed98f49a387ae1dd3e0cc185e8aa602b81da7585b77b237381fbc95e2982" args="" -->THREAD_PRIORITY_NOMINAL</em>&nbsp;</td><td>
<p>An average priority. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1f57fed98f49a387ae1dd3e0cc185e8aa648c3a9cf6ccc3564c50df7150ceee6c"></a><!-- doxytag: member="THREAD_PRIORITY_LOW" ref="a1f57fed98f49a387ae1dd3e0cc185e8aa648c3a9cf6ccc3564c50df7150ceee6c" args="" -->THREAD_PRIORITY_LOW</em>&nbsp;</td><td>
<p>A low (but not min) setting. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1f57fed98f49a387ae1dd3e0cc185e8aaa650066dc1919eb45e2ff21cfb95fa41"></a><!-- doxytag: member="THREAD_PRIORITY_MIN" ref="a1f57fed98f49a387ae1dd3e0cc185e8aaa650066dc1919eb45e2ff21cfb95fa41" args="" -->THREAD_PRIORITY_MIN</em>&nbsp;</td><td>
<p>The miniumum possible priority. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1f57fed98f49a387ae1dd3e0cc185e8aa04fd8e4a307e9ba44a526c8f092e5c5a"></a><!-- doxytag: member="THREAD_PRIORITY_DEFAULT" ref="a1f57fed98f49a387ae1dd3e0cc185e8aa04fd8e4a307e9ba44a526c8f092e5c5a" args="" -->THREAD_PRIORITY_DEFAULT</em>&nbsp;</td><td>
<p>Priority scheduling default. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6bc90253917b28b50c2647203dd2ae5a"></a><!-- doxytag: member="OpenThreads::Thread::Thread" ref="a6bc90253917b28b50c2647203dd2ae5a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenThreads::Thread::Thread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="ae2926edc9f776621253c389d58bd695b"></a><!-- doxytag: member="OpenThreads::Thread::~Thread" ref="ae2926edc9f776621253c389d58bd695b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OpenThreads::Thread::~Thread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abe4a808c444f7548520680e6bfa1dbfc"></a><!-- doxytag: member="OpenThreads::Thread::cancel" ref="abe4a808c444f7548520680e6bfa1dbfc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OpenThreads::Thread::cancel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel the thread. </p>
<p>Equivalent to SIGKILL.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bebbad70a956a47e30737298becc51f"></a><!-- doxytag: member="OpenThreads::Thread::cancelCleanup" ref="a3bebbad70a956a47e30737298becc51f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OpenThreads::Thread::cancelCleanup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Thread's cancel cleanup routine, called upon <a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc" title="Cancel the thread.">cancel()</a>, after the cancelation has taken place, but before the thread exits completely. </p>
<p>This method should be used to repair parts of the thread's data that may have been damaged by a pre-mature cancel. No-op by default. </p>

</div>
</div>
<a class="anchor" id="a1760ce9beb19bcf222ab8ac86b6c58d6"></a><!-- doxytag: member="OpenThreads::Thread::CurrentThread" ref="a1760ce9beb19bcf222ab8ac86b6c58d6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00016.html">Thread</a>* OpenThreads::Thread::CurrentThread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a pointer to the current running thread. </p>

<p>Referenced by <a class="el" href="a00009.html#ab02bc64ed063c4021d4f312595eb193b">OpenThreads::ReentrantMutex::lock()</a>, <a class="el" href="a00009.html#aaa8f7f28c222cb3973c5fa41a370ead6">OpenThreads::ReentrantMutex::trylock()</a>, and <a class="el" href="a00009.html#a47ce1de709f9d0e49abe58a5248978e9">OpenThreads::ReentrantMutex::unlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ac2e01b8769557110f11f6fbfa5b5aba6"></a><!-- doxytag: member="OpenThreads::Thread::detach" ref="ac2e01b8769557110f11f6fbfa5b5aba6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::detach </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detach the thread from the calling process. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="adee75f3a133fc285b25e723cfa2ed6eb"></a><!-- doxytag: member="OpenThreads::Thread::GetConcurrency" ref="adee75f3a133fc285b25e723cfa2ed6eb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenThreads::Thread::GetConcurrency </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the concurrency level for a running application. </p>
<p>In this case, a return code of 0 means that the application is in default mode. A return code of -1 means that the application is incapable of setting an arbitrary concurrency, because it is a one-to-one execution model (sprocs, linuxThreads) </p>

</div>
</div>
<a class="anchor" id="a27e0b385c49d1f57e2ecb8363d3641d1"></a><!-- doxytag: member="OpenThreads::Thread::getImplementation" ref="a27e0b385c49d1f57e2ecb8363d3641d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* OpenThreads::Thread::getImplementation </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aff79998cc4b7360d3d80120c8fb88b61"></a><!-- doxytag: member="OpenThreads::Thread::GetMasterPriority" ref="aff79998cc4b7360d3d80120c8fb88b61" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a">ThreadPriority</a> OpenThreads::Thread::GetMasterPriority </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method will return the ThreadPriority of the master process. </p>
<p>(ie, the one calling the thread-&gt;<a class="el" href="a00016.html#ae52eaf0475bc84991cc9f96d64783b84" title="Start the thread.">start()</a> methods for the first time) The method will almost certainly return <a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8aa04fd8e4a307e9ba44a526c8f092e5c5a" title="Priority scheduling default.">Thread::THREAD_PRIORITY_DEFAULT</a> if <a class="el" href="a00016.html#af988ef894b393b5dbc250c21cea0ae2d" title="Initialize Threading in a program.">Init()</a> has not been called.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a" title="Enumerated Type for thread priority.">Thread::ThreadPriority</a> of the master thread. </dd></dl>

</div>
</div>
<a class="anchor" id="af607d54c7c72922687e7ed0c6ff3bc09"></a><!-- doxytag: member="OpenThreads::Thread::getProcessId" ref="af607d54c7c72922687e7ed0c6ff3bc09" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OpenThreads::Thread::getProcessId </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the thread's process id. </p>
<p>This is the pthread_t or pid_t value depending on the threading model being used.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>thread process id. </dd></dl>

</div>
</div>
<a class="anchor" id="aea5d04ad5853479e6e078b46a0e98d50"></a><!-- doxytag: member="OpenThreads::Thread::getSchedulePolicy" ref="aea5d04ad5853479e6e078b46a0e98d50" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::getSchedulePolicy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the thread's policy (if able). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>seting the environment variable OUTPUT_THREADLIB_SCHEDULING_INFO will output scheduling information for each thread to stdout.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>policy if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9243e10f7dcad7b5f478c8af439fb276"></a><!-- doxytag: member="OpenThreads::Thread::getSchedulePriority" ref="a9243e10f7dcad7b5f478c8af439fb276" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::getSchedulePriority </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the thread's schedule priority (if able). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>seting the environment variable OUTPUT_THREADLIB_SCHEDULING_INFO will output scheduling information for each thread to stdout.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab931488a56f81dfbdfe176ff86eacbc3"></a><!-- doxytag: member="OpenThreads::Thread::getStackSize" ref="ab931488a56f81dfbdfe176ff86eacbc3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OpenThreads::Thread::getStackSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the thread's desired stack size. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the thread's stack size. 0 indicates that the stack size has either not yet been initialized, or not yet been specified by the application. </dd></dl>

</div>
</div>
<a class="anchor" id="a62b30f90878282381a5fc13e7ce6b3a1"></a><!-- doxytag: member="OpenThreads::Thread::getThreadId" ref="a62b30f90878282381a5fc13e7ce6b3a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::getThreadId </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a unique thread id. </p>
<p>This id is monotonically increasing.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a unique thread identifier </dd></dl>

</div>
</div>
<a class="anchor" id="af988ef894b393b5dbc250c21cea0ae2d"></a><!-- doxytag: member="OpenThreads::Thread::Init" ref="af988ef894b393b5dbc250c21cea0ae2d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenThreads::Thread::Init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize Threading in a program. </p>
<p>This method must be called before you can do any threading in a program. </p>

</div>
</div>
<a class="anchor" id="a96d8f223f11c3a71f1785a2112051633"></a><!-- doxytag: member="OpenThreads::Thread::isRunning" ref="a96d8f223f11c3a71f1785a2112051633" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenThreads::Thread::isRunning </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the thread's running status. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if running, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ab451f90cde2c3f87f8dc2c9a5faad979"></a><!-- doxytag: member="OpenThreads::Thread::join" ref="ab451f90cde2c3f87f8dc2c9a5faad979" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::join </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Join the calling process with the thread. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a19f97253ae90bb5e137cf96d82023220"></a><!-- doxytag: member="OpenThreads::Thread::microSleep" ref="a19f97253ae90bb5e137cf96d82023220" args="(unsigned int microsec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenThreads::Thread::microSleep </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>microsec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>microSleep method, equivilant to the posix usleep(microsec). </p>
<p>This is not strictly thread API but is used so often with threads. It's basically UNIX usleep. Parameter is number of microseconds we current thread to sleep. Returns 0 on succes, non-zero on failure (UNIX errno or GetLastError() will give detailed description. </p>

</div>
</div>
<a class="anchor" id="a4e8df0a910c9929182fb7fb31f57ce4f"></a><!-- doxytag: member="OpenThreads::Thread::printSchedulingInfo" ref="a4e8df0a910c9929182fb7fb31f57ce4f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenThreads::Thread::printSchedulingInfo </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the thread's scheduling information to stdout. </p>

</div>
</div>
<a class="anchor" id="afb802d904cca9e3206149a9efe1f83e4"></a><!-- doxytag: member="OpenThreads::Thread::run" ref="afb802d904cca9e3206149a9efe1f83e4" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OpenThreads::Thread::run </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Thread's run method. </p>
<p>Must be implemented by derived classes. This is where the action happens. </p>

</div>
</div>
<a class="anchor" id="a270bb39ee3c65b87d4016809e32de737"></a><!-- doxytag: member="OpenThreads::Thread::setCancelModeAsynchronous" ref="a270bb39ee3c65b87d4016809e32de737" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::setCancelModeAsynchronous </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mark the thread to cancel aysncronously on <a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc" title="Cancel the thread.">Thread::cancel()</a>. </p>
<p>(May not be available with process-level implementations).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afc485fe54a15b8a445725f838193158d"></a><!-- doxytag: member="OpenThreads::Thread::setCancelModeDeferred" ref="afc485fe54a15b8a445725f838193158d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::setCancelModeDeferred </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mark the thread to cancel at the earliest convenience on <a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc" title="Cancel the thread.">Thread::cancel()</a> (This is the default). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a71634250a1e70b4396400cfa011dff18"></a><!-- doxytag: member="OpenThreads::Thread::setCancelModeDisable" ref="a71634250a1e70b4396400cfa011dff18" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::setCancelModeDisable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable thread cancelation altogether. </p>
<p><a class="el" href="a00016.html#abe4a808c444f7548520680e6bfa1dbfc" title="Cancel the thread.">Thread::cancel()</a> has no effect.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1369402cdf698506e1304723cb08057d"></a><!-- doxytag: member="OpenThreads::Thread::SetConcurrency" ref="a1369402cdf698506e1304723cb08057d" args="(int concurrencyLevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenThreads::Thread::SetConcurrency </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>concurrencyLevel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the concurrency level for a running application. </p>
<p>This method only has effect if the pthreads thread model is being used, and then only when that model is many-to-one (eg. irix). in other cases it is ignored. The concurrency level is only a *hint* as to the number of execution vehicles to use, the actual implementation may do anything it wants. Setting the value to 0 returns things to their default state.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>previous concurrency level, -1 indicates no-op. </dd></dl>

</div>
</div>
<a class="anchor" id="a91efa532982ea5a89a485a802617b2e2"></a><!-- doxytag: member="OpenThreads::Thread::setProcessorAffinity" ref="a91efa532982ea5a89a485a802617b2e2" args="(unsigned int cpunum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::setProcessorAffinity </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>cpunum</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Thread's processor affinity method. </p>
<p>This binds a thread to a processor whenever possible. This call must be made before <a class="el" href="a00016.html#ae52eaf0475bc84991cc9f96d64783b84" title="Start the thread.">start()</a> or <a class="el" href="a00016.html#a856e61d61aec17cef517a24e542b8778">startThread()</a> and has no effect after the thread has been running. In the pthreads implementation, this is only implemented on sgi, through a pthread extension. On other pthread platforms this is ignored. Returns 0 on success, implementation's error on failure, or -1 if ignored. </p>

</div>
</div>
<a class="anchor" id="a69641fb3ee2b57d3180fbc14608447f8"></a><!-- doxytag: member="OpenThreads::Thread::setSchedulePolicy" ref="a69641fb3ee2b57d3180fbc14608447f8" args="(ThreadPolicy policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::setSchedulePolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00016.html#a40f88ee2a59fb412061db2d7970e579b">ThreadPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>policy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the thread's scheduling policy (if able). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>On some implementations (notably IRIX Sprocs &amp; LinuxThreads) The policy may prohibit the use of SCHEDULE_ROUND_ROBIN and SCHEDULE_FIFO policies - due to their real-time nature, and the danger of deadlocking the machine when used as super-user. In such cases, the command is a no-op.</dd>
<dd>
seting the environment variable OUTPUT_THREADLIB_SCHEDULING_INFO will output scheduling information for each thread to stdout.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cc88b654a3ad4a5819def841cdf4614"></a><!-- doxytag: member="OpenThreads::Thread::setSchedulePriority" ref="a2cc88b654a3ad4a5819def841cdf4614" args="(ThreadPriority priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::setSchedulePriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00016.html#a1f57fed98f49a387ae1dd3e0cc185e8a">ThreadPriority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the thread's schedule priority. </p>
<p>This is a complex method. Beware of thread priorities when using a many-to-many kernel entity implemenation (such as IRIX pthreads). If one is not carefull to manage the thread priorities, a priority inversion deadlock can easily occur (Although the <a class="el" href="a00007.html" title="This class provides an object-oriented thread mutex interface.">OpenThreads::Mutex</a> &amp; <a class="el" href="a00003.html" title="This class provides an object-oriented thread barrier interface.">OpenThreads::Barrier</a> constructs have been designed with this senario in mind). Unless you have explicit need to set the schedule pirorites for a given task, it is best to leave them alone.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>some implementations (notably LinuxThreads and IRIX Sprocs) only alow you to decrease thread priorities dynamically. Thus, a lower priority thread will not allow it's priority to be raised on the fly.</dd>
<dd>
seting the environment variable OUTPUT_THREADLIB_SCHEDULING_INFO will output scheduling information for each thread to stdout.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3eb85b3440b099ea8447e6f8755aa830"></a><!-- doxytag: member="OpenThreads::Thread::setStackSize" ref="a3eb85b3440b099ea8447e6f8755aa830" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::setStackSize </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the thread's desired stack size (in bytes). </p>
<p>This method is an attribute of the thread and must be called *before* the <a class="el" href="a00016.html#ae52eaf0475bc84991cc9f96d64783b84" title="Start the thread.">start()</a> method is invoked.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>a return code of 13 (EACESS) means that the thread stack size can no longer be changed.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae52eaf0475bc84991cc9f96d64783b84"></a><!-- doxytag: member="OpenThreads::Thread::start" ref="ae52eaf0475bc84991cc9f96d64783b84" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start the thread. </p>
<p>This method will configure the thread, set it's priority, and spawn it.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>if the stack size specified setStackSize is smaller than the smallest allowable stack size, the threads stack size will be set to the minimum allowed, and may be retrieved via the <a class="el" href="a00016.html#ab931488a56f81dfbdfe176ff86eacbc3" title="Get the thread&#39;s desired stack size.">getStackSize()</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a856e61d61aec17cef517a24e542b8778"></a><!-- doxytag: member="OpenThreads::Thread::startThread" ref="a856e61d61aec17cef517a24e542b8778" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::startThread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a989e6a1153973a7d68c423892f9022c5"></a><!-- doxytag: member="OpenThreads::Thread::testCancel" ref="a989e6a1153973a7d68c423892f9022c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenThreads::Thread::testCancel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test the cancel state of the thread. </p>
<p>If the thread has been canceled this method will cause the thread to exit now. This method operates on the calling thread.</p>
<p>Returns 0 if normal, -1 if called from a thread other that this. </p>

</div>
</div>
<a class="anchor" id="a76a5bba0a8865c880f984c6df383eb7d"></a><!-- doxytag: member="OpenThreads::Thread::YieldCurrentThread" ref="a76a5bba0a8865c880f984c6df383eb7d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenThreads::Thread::YieldCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Yield the processor. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method operates on the calling process. And is equivalent to calling sched_yield().</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if normal, -1 if errno set, errno code otherwise. </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a2a1b7d1a2228897da066a0bd92589ba9"></a><!-- doxytag: member="OpenThreads::Thread::ThreadPrivateActions" ref="a2a1b7d1a2228897da066a0bd92589ba9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class ThreadPrivateActions<code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Private Actions class is allowed to operate on private data. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>OpenThreads/<a class="el" href="a00027.html">Thread</a></li>
</ul>
</div>
<hr>
<table border="0"><tr><td>
  <img src="osg32-32.png" alt="osg logo" />
</td><td>
  <address><small>Generated at Thu Jun 9 2011 16:37:29 for the <a href="http://www.openscenegraph.org/">OpenThreads</a>
by <a href="http://www.doxygen.org">doxygen</a> 1.7.1.</small></address>
<!-- Dimitri van Heesch's e-mail address removed, lest he get messages on the OpenSceneGraph -->
</td></tr></table>
</body>
</html>
