<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenSceneGraph: osg::Group Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="a01635.html">osg</a>      </li>
      <li><a class="el" href="a00338.html">osg::Group</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>osg::Group Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="osg::Group" --><!-- doxytag: inherits="osg::Node" -->
<p>General group node which maintains a list of children.  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for osg::Group:</div>
<div class="dyncontent">
<div class="center"><img src="a02089.png" border="0" usemap="#osg_1_1Group_inherit__map" alt="Inheritance graph"/></div>
<map name="osg_1_1Group_inherit__map" id="osg_1_1Group_inherit__map">
<area shape="rect" id="node9" href="a00104.html" title="A Group node for clearing the color and depth buffers." alt="" coords="619,5,728,35"/><area shape="rect" id="node11" href="a00105.html" title="Node for defining the position of ClipPlanes in the scene." alt="" coords="623,58,724,89"/><area shape="rect" id="node13" href="a00168.html" title="CoordinateSystem encapsulate the coordinate system that is associated with objects in a scene..." alt="" coords="580,111,767,142"/><area shape="rect" id="node15" href="a00434.html" title="Leaf Node for defining a light in the scene." alt="" coords="613,165,733,195"/><area shape="rect" id="node17" href="a00451.html" title="LOD &#45; Level Of Detail group node which allows switching between children depending on distance from e..." alt="" coords="636,218,711,249"/><area shape="rect" id="node23" href="a00510.html" title="OccluderNode is a Group node which allows OccluderNodeing between children." alt="" coords="607,271,740,302"/><area shape="rect" id="node25" href="a00511.html" title="osg::OcclusionQueryNode" alt="" coords="587,325,760,355"/><area shape="rect" id="node27" href="a00583.html" title="Projection nodes set up the frustum/orthographic projection used when rendering the scene..." alt="" coords="619,378,728,409"/><area shape="rect" id="node29" href="a00603.html" title="ProxyNode." alt="" coords="616,431,731,462"/><area shape="rect" id="node31" href="a00698.html" title="Sequence is a Group node which allows automatic, time based switching between children." alt="" coords="619,485,728,515"/><area shape="rect" id="node33" href="a00852.html" title="Switch is a Group node that allows switching between children." alt="" coords="628,538,719,569"/><area shape="rect" id="node37" href="a00894.html" title="Node for defining the position of TexGen in the scene." alt="" coords="611,591,736,622"/><area shape="rect" id="node39" href="a00928.html" title="A Transform is a group node for which all children are transformed by a 4x4 matrix." alt="" coords="619,645,728,675"/><area shape="rect" id="node57" href="a00240.html" title="The base class for special effects." alt="" coords="623,698,724,729"/><area shape="rect" id="node69" href="a00487.html" title="This node provides control over the which texture units are active and the blending weighting between..." alt="" coords="584,751,763,782"/><area shape="rect" id="node71" href="a00541.html" title="osgParticle::ParticleEffect" alt="" coords="588,805,759,835"/><area shape="rect" id="node83" href="a00706.html" title="ShadowedScene provides a mechansim for decorating a scene that the needs to have shadows cast upon it..." alt="" coords="576,858,771,889"/><area shape="rect" id="node85" href="a00486.html" title="MultiSwitch is a Group node which allows switching between sets of selected children." alt="" coords="603,911,744,942"/><area shape="rect" id="node87" href="a00533.html" title="OverlayNode is for creating texture overlays on scenes, with the overlay texture being generated by p..." alt="" coords="599,965,748,995"/><area shape="rect" id="node89" href="a01102.html" title="VisibilityGroup renders (traverses) it&#39;s children only when the camera is inside a specified visi..." alt="" coords="595,1018,752,1049"/><area shape="rect" id="node91" href="a00881.html" title="Terrain provides a framework for loosely coupling height field data with height rendering algorithms..." alt="" coords="609,1071,737,1102"/><area shape="rect" id="node93" href="a00884.html" title="Terrain provides a framework for loosely coupling height field data with height rendering algorithms..." alt="" coords="599,1125,748,1155"/><area shape="rect" id="node95" href="a01105.html" title="Volume provides a framework for loosely coupling 3d image VolumeTile&#39;s with volume algorithms..." alt="" coords="605,1178,741,1209"/><area shape="rect" id="node97" href="a01107.html" title="VolumeTile provides a framework for loosely coupling 3d image data with rendering algorithms..." alt="" coords="595,1231,752,1262"/><area shape="rect" id="node2" href="a00491.html" title="Base class for all internal nodes in the scene graph." alt="" coords="311,618,391,649"/><area shape="rect" id="node4" href="a00501.html" title="Base class/standard interface for objects which require IO support, cloning and reference counting..." alt="" coords="172,618,260,649"/><area shape="rect" id="node6" href="a00629.html" title="Base class from providing referencing counted objects." alt="" coords="5,618,123,649"/><area shape="rect" id="node19" href="a00534.html" title="PagedLOD." alt="" coords="875,165,987,195"/><area shape="rect" id="node21" href="a00363.html" title="Impostor &#45; is a form of Level Of Detail group node which allows both switching between children depen..." alt="" coords="868,218,993,249"/><area shape="rect" id="node35" href="a01115.html" title="osgWidget::WindowManager" alt="" coords="837,271,1024,302"/><area shape="rect" id="node41" href="a00045.html" title="AutoTransform is a derived form of Transform that automatically scales or rotates to keep its childre..." alt="" coords="863,325,999,355"/><area shape="rect" id="node43" href="a00087.html" title="Camera &#45; is a subclass of Transform which represents encapsulates the settings of a Camera..." alt="" coords="883,378,979,409"/><area shape="rect" id="node45" href="a00091.html" title="CameraView &#45; is a Transform that is used to specify camera views from within the scene graph..." alt="" coords="869,431,992,462"/><area shape="rect" id="node47" href="a00464.html" title="MatrixTransform &#45; is a subclass of Transform which has an osg::Matrix which represents a 4x4 transfor..." alt="" coords="859,485,1003,515"/><area shape="rect" id="node53" href="a00573.html" title="PositionAttitudeTransform &#45; is a Transform." alt="" coords="831,538,1031,569"/><area shape="rect" id="node55" href="a00213.html" title="DOFTransform &#45; encapsulates Multigen DOF behavior." alt="" coords="852,591,1009,622"/><area shape="rect" id="node49" href="a00062.html" title="osgAnimation::Bone" alt="" coords="1101,458,1240,489"/><area shape="rect" id="node51" href="a00722.html" title="osgAnimation::Skeleton" alt="" coords="1091,511,1251,542"/><area shape="rect" id="node59" href="a00026.html" title="This single&#45;pass effect implements a sort of anisotropic lighting that replaces the standard OpenGL l..." alt="" coords="841,645,1020,675"/><area shape="rect" id="node61" href="a00081.html" title="This effect makes surfaces appear bumpy." alt="" coords="856,698,1005,729"/><area shape="rect" id="node63" href="a00096.html" title="This effect implements a technique called &#39;Cel&#45;Shading&#39; to produce a cartoon&#45;style (non photo..." alt="" coords="875,751,987,782"/><area shape="rect" id="node65" href="a00692.html" title="This is a two&#45;passes effect; the first pass renders the subgraph as usual while the second pass switc..." alt="" coords="879,805,983,835"/><area shape="rect" id="node67" href="a00731.html" title="This effect applies additive specular highlights at fragment level (instead of OpenGL&#39;s vertex&#45;le..." alt="" coords="843,858,1019,889"/><area shape="rect" id="node73" href="a00260.html" title="osgParticle::ExplosionDebrisEffect" alt="" coords="820,911,1041,942"/><area shape="rect" id="node75" href="a00261.html" title="osgParticle::ExplosionEffect" alt="" coords="837,965,1024,995"/><area shape="rect" id="node77" href="a00287.html" title="osgParticle::FireEffect" alt="" coords="856,1018,1005,1049"/><area shape="rect" id="node79" href="a00724.html" title="osgParticle::SmokeEffect" alt="" coords="845,1071,1016,1102"/><area shape="rect" id="node81" href="a00725.html" title="osgParticle::SmokeTrailEffect" alt="" coords="833,1125,1028,1155"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="a02090.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#ac00d17729018703526544a0983237dff">Group</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a610e4825abb90fd8a89963469da5dd20">Group</a> (const <a class="el" href="a00338.html">Group</a> &amp;, const <a class="el" href="a00169.html">CopyOp</a> &amp;copyop=CopyOp::SHALLOW_COPY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor using <a class="el" href="a00169.html" title="Copy Op(erator) used to control whether shallow or deep copy is used during copy construction and clo...">CopyOp</a> to manage deep vs shallow copy.  <a href="#a610e4825abb90fd8a89963469da5dd20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a3c91554838f06c77fdc1c88ebe3487e1">META_Node</a> (osg, <a class="el" href="a00338.html">Group</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00338.html">Group</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a4528ad56c755b53021fcddf8a7c5c2bf">asGroup</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert 'this' into a <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>, otherwise return 0.  <a href="#a4528ad56c755b53021fcddf8a7c5c2bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="a00338.html">Group</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#ac51a58f84828cef43160d5f620220906">asGroup</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert 'const this' into a const <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>, otherwise return 0.  <a href="#ac51a58f84828cef43160d5f620220906"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a189db7193e544ac67947c982b39aa435">traverse</a> (<a class="el" href="a00497.html">NodeVisitor</a> &amp;nv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traverse downwards : calls children's accept method with <a class="el" href="a00497.html" title="Visitor for type safe operations on osg::Nodes.">NodeVisitor</a>.  <a href="#a189db7193e544ac67947c982b39aa435"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#aa1192dd83d1efa5b2f360eff8c4ea6fc">addChild</a> (<a class="el" href="a00491.html">Node</a> *child)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> to <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>.  <a href="#aa1192dd83d1efa5b2f360eff8c4ea6fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a74425c5534e0ea76e936716f95e51986">insertChild</a> (unsigned int index, <a class="el" href="a00491.html">Node</a> *child)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> to <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a> at specific location.  <a href="#a74425c5534e0ea76e936716f95e51986"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a799af18caae45018d77d53c7520b3c1d">removeChild</a> (<a class="el" href="a00491.html">Node</a> *child)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> from <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>.  <a href="#a799af18caae45018d77d53c7520b3c1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#aadb5f67516d3dbc3a21a6137171d8719">removeChild</a> (unsigned int pos, unsigned int numChildrenToRemove=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> from <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>.  <a href="#aadb5f67516d3dbc3a21a6137171d8719"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a1bf3c672b6cf9438b252dc73c09f6275">removeChildren</a> (unsigned int pos, unsigned int numChildrenToRemove)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove children from <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>.  <a href="#a1bf3c672b6cf9438b252dc73c09f6275"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a35a06b4a55bda8c4084683000bc5f53b">replaceChild</a> (<a class="el" href="a00491.html">Node</a> *origChild, <a class="el" href="a00491.html">Node</a> *newChild)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace specified <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> with another <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a>.  <a href="#a35a06b4a55bda8c4084683000bc5f53b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#afc73d81580856f649c57021d156d0172">getNumChildren</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of children nodes.  <a href="#afc73d81580856f649c57021d156d0172"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a2644540e4268f9f61b22b9a0fda99468">setChild</a> (unsigned int i, <a class="el" href="a00491.html">Node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set child node at position i.  <a href="#a2644540e4268f9f61b22b9a0fda99468"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00491.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a8774ba3833bee92d027f30722497ff46">getChild</a> (unsigned int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return child node at position i.  <a href="#a8774ba3833bee92d027f30722497ff46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00491.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#ae51ca0c3cc7dbcbbdcce2877b37a56de">getChild</a> (unsigned int i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return child node at position i.  <a href="#ae51ca0c3cc7dbcbbdcce2877b37a56de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a5b7d6aa9a106792464684790f6b377e4">containsNode</a> (const <a class="el" href="a00491.html">Node</a> *node) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if node is contained within <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>.  <a href="#a5b7d6aa9a106792464684790f6b377e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a9d5007a38e1b0ef3132b7b2d2783c358">getChildIndex</a> (const <a class="el" href="a00491.html">Node</a> *node) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the index number of child, return a value between 0 and _children.size()-1 if found, if not found then return _children.size().  <a href="#a9d5007a38e1b0ef3132b7b2d2783c358"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a6b86895eb8b3ab999cd6a46f5aaaae64">setThreadSafeRefUnref</a> (bool threadSafe)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to use a mutex to ensure <a class="el" href="a00629.html#acafcbbae9e9d8bfcbc811cc6c36d1cf4" title="Increment the reference count by one, indicating that this object has another pointer which is refere...">ref()</a> and <a class="el" href="a00629.html#a0ee3c1293cceac54bfaabe7c541bcb68" title="Decrement the reference count by one, indicating that a pointer to this object is referencing it...">unref()</a> are thread safe.  <a href="#a6b86895eb8b3ab999cd6a46f5aaaae64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a4049ebe617e25b77f24001c86ca16f07">resizeGLObjectBuffers</a> (unsigned int maxSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize any per context GLObject buffers to specified size.  <a href="#a4049ebe617e25b77f24001c86ca16f07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#add2ef7fed87eb083a46776e122b9991f">releaseGLObjects</a> (<a class="el" href="a00745.html">osg::State</a> *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <a class="el" href="a00745.html" title="Encapsulates the current applied OpenGL modes, attributes and vertex arrays settings, implements lazy state updating and provides accessors for querying the current state.">State</a> is non-zero, this function releases any associated OpenGL objects for the specified graphics context.  <a href="#add2ef7fed87eb083a46776e122b9991f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00070.html">BoundingSphere</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#ab95d0f7f693111e5b5ec57ce786d2d1a">computeBound</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the bounding sphere around Node's geometry or children.  <a href="#ab95d0f7f693111e5b5ec57ce786d2d1a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a70c9609d197baca7e09ac1b01ccda602">~Group</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a126b646e457c0a277ca6601187b813a9">childRemoved</a> (unsigned int, unsigned int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#a0545a0e7065867a697b32214316f9419">childInserted</a> (unsigned int)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01635.html#a42930b9d8d4f107bf147a3e438aa1654">NodeList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html#ad046a9d7384b5183d42fc36ef32433dd">_children</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>General group node which maintains a list of children. </p>
<p>Children are reference counted. This allows children to be shared with memory management handled automatically via <a class="el" href="a00629.html" title="Base class from providing referencing counted objects.">osg::Referenced</a>. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac00d17729018703526544a0983237dff"></a><!-- doxytag: member="osg::Group::Group" ref="ac00d17729018703526544a0983237dff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osg::Group::Group </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a610e4825abb90fd8a89963469da5dd20"></a><!-- doxytag: member="osg::Group::Group" ref="a610e4825abb90fd8a89963469da5dd20" args="(const Group &amp;, const CopyOp &amp;copyop=CopyOp::SHALLOW_COPY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osg::Group::Group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00338.html">Group</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00169.html">CopyOp</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyop</em> = <code>CopyOp::SHALLOW_COPY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor using <a class="el" href="a00169.html" title="Copy Op(erator) used to control whether shallow or deep copy is used during copy construction and clo...">CopyOp</a> to manage deep vs shallow copy. </p>

</div>
</div>
<a class="anchor" id="a70c9609d197baca7e09ac1b01ccda602"></a><!-- doxytag: member="osg::Group::~Group" ref="a70c9609d197baca7e09ac1b01ccda602" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual osg::Group::~Group </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa1192dd83d1efa5b2f360eff8c4ea6fc"></a><!-- doxytag: member="osg::Group::addChild" ref="aa1192dd83d1efa5b2f360eff8c4ea6fc" args="(Node *child)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool osg::Group::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00491.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> to <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>. </p>
<p>If node is not NULL and is not contained in <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a> then increment its reference count, add it to the child list and dirty the bounding sphere to force it to recompute on next <a class="el" href="a00491.html#a1467f2ad703474ad37a236f87dee1f3a" title="Get the bounding sphere of node.">getBound()</a> and return true for success. Otherwise return false. Scene nodes can't be added as child nodes. </p>

<p>Reimplemented in <a class="el" href="a00451.html#a1edb456430c1438354a6a4075fd7b6d3">osg::LOD</a>, <a class="el" href="a00534.html#ab56e84ed0b5502de4bc829ad23c5f624">osg::PagedLOD</a>, <a class="el" href="a00603.html#a7e0757f723137588273bb29d3fccbcfb">osg::ProxyNode</a>, <a class="el" href="a00698.html#a5c6f04f8207c1cf9836153ee1558f5fc">osg::Sequence</a>, <a class="el" href="a00852.html#a75d349a5ff9407d3fdfa8e9eeebedac2">osg::Switch</a>, and <a class="el" href="a00486.html#a0fff3039aba9875cb06aca664cb4baa7">osgSim::MultiSwitch</a>.</p>

</div>
</div>
<a class="anchor" id="a4528ad56c755b53021fcddf8a7c5c2bf"></a><!-- doxytag: member="osg::Group::asGroup" ref="a4528ad56c755b53021fcddf8a7c5c2bf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00338.html">Group</a>* osg::Group::asGroup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convert 'this' into a <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>, otherwise return 0. </p>
<p>Equivalent to dynamic_cast&lt;Group*&gt;(this). </p>

<p>Reimplemented from <a class="el" href="a00491.html#a5685f61aec39a1df350b2e707cea05cc">osg::Node</a>.</p>

</div>
</div>
<a class="anchor" id="ac51a58f84828cef43160d5f620220906"></a><!-- doxytag: member="osg::Group::asGroup" ref="ac51a58f84828cef43160d5f620220906" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="a00338.html">Group</a>* osg::Group::asGroup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convert 'const this' into a const <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>, otherwise return 0. </p>
<p>Equivalent to dynamic_cast&lt;const Group*&gt;(this). </p>

<p>Reimplemented from <a class="el" href="a00491.html#aad6973a39010d3c44e91301204680df5">osg::Node</a>.</p>

</div>
</div>
<a class="anchor" id="a0545a0e7065867a697b32214316f9419"></a><!-- doxytag: member="osg::Group::childInserted" ref="a0545a0e7065867a697b32214316f9419" args="(unsigned int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void osg::Group::childInserted </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>int</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a126b646e457c0a277ca6601187b813a9"></a><!-- doxytag: member="osg::Group::childRemoved" ref="a126b646e457c0a277ca6601187b813a9" args="(unsigned int, unsigned int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void osg::Group::childRemoved </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>int</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab95d0f7f693111e5b5ec57ce786d2d1a"></a><!-- doxytag: member="osg::Group::computeBound" ref="ab95d0f7f693111e5b5ec57ce786d2d1a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00070.html">BoundingSphere</a> osg::Group::computeBound </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the bounding sphere around Node's geometry or children. </p>
<p>This method is automatically called by <a class="el" href="a00491.html#a1467f2ad703474ad37a236f87dee1f3a" title="Get the bounding sphere of node.">getBound()</a> when the bounding sphere has been marked dirty via <a class="el" href="a00491.html#ae0c87d5abfa0b64bca79600b77e0f7ba" title="Mark this node&#39;s bounding sphere dirty.">dirtyBound()</a>. </p>

<p>Reimplemented from <a class="el" href="a00491.html#ac3098a0de0b680b7bf1ebd3547f09cce">osg::Node</a>.</p>

<p>Reimplemented in <a class="el" href="a00045.html#a03e9003afc4991c6e532b91b184c4356">osg::AutoTransform</a>, <a class="el" href="a00105.html#ad9cbfc5ee174a1ba80df8038fcc09cca">osg::ClipNode</a>, <a class="el" href="a00434.html#aa8238ec89af5f40a804057d680189254">osg::LightSource</a>, <a class="el" href="a00451.html#acd6a505622a771a686b38d85b0ce2043">osg::LOD</a>, <a class="el" href="a00510.html#aae44ecbb46d94102c4231a1a2bb2254b">osg::OccluderNode</a>, <a class="el" href="a00511.html#a779fa965174a74ca586f98308d898f77">osg::OcclusionQueryNode</a>, <a class="el" href="a00603.html#a89a34dd2cd5b58ab4d04328fc3ba123b">osg::ProxyNode</a>, <a class="el" href="a00852.html#a31c731c6f4e3ca4aa785080c39b0eca5">osg::Switch</a>, <a class="el" href="a00928.html#a87d6acb280aee16afcd6a953450610e5">osg::Transform</a>, <a class="el" href="a00363.html#add2312d3d0601c45f8a40665ad219035">osgSim::Impostor</a>, <a class="el" href="a00884.html#aa26d396c95139afaa44d6e2703e96257">osgTerrain::TerrainTile</a>, and <a class="el" href="a01107.html#ad6044f8a96c98d5e067ff0cfef58cae9">osgVolume::VolumeTile</a>.</p>

</div>
</div>
<a class="anchor" id="a5b7d6aa9a106792464684790f6b377e4"></a><!-- doxytag: member="osg::Group::containsNode" ref="a5b7d6aa9a106792464684790f6b377e4" args="(const Node *node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osg::Group::containsNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00491.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if node is contained within <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>. </p>

</div>
</div>
<a class="anchor" id="a8774ba3833bee92d027f30722497ff46"></a><!-- doxytag: member="osg::Group::getChild" ref="a8774ba3833bee92d027f30722497ff46" args="(unsigned int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00491.html">Node</a>* osg::Group::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return child node at position i. </p>

</div>
</div>
<a class="anchor" id="ae51ca0c3cc7dbcbbdcce2877b37a56de"></a><!-- doxytag: member="osg::Group::getChild" ref="ae51ca0c3cc7dbcbbdcce2877b37a56de" args="(unsigned int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00491.html">Node</a>* osg::Group::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return child node at position i. </p>

</div>
</div>
<a class="anchor" id="a9d5007a38e1b0ef3132b7b2d2783c358"></a><!-- doxytag: member="osg::Group::getChildIndex" ref="a9d5007a38e1b0ef3132b7b2d2783c358" args="(const Node *node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int osg::Group::getChildIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00491.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the index number of child, return a value between 0 and _children.size()-1 if found, if not found then return _children.size(). </p>

</div>
</div>
<a class="anchor" id="afc73d81580856f649c57021d156d0172"></a><!-- doxytag: member="osg::Group::getNumChildren" ref="afc73d81580856f649c57021d156d0172" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int osg::Group::getNumChildren </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of children nodes. </p>

</div>
</div>
<a class="anchor" id="a74425c5534e0ea76e936716f95e51986"></a><!-- doxytag: member="osg::Group::insertChild" ref="a74425c5534e0ea76e936716f95e51986" args="(unsigned int index, Node *child)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool osg::Group::insertChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00491.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> to <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a> at specific location. </p>
<p>The new child node is inserted into the child list before the node at the specified index. No nodes are removed from the group with this operation. </p>

<p>Reimplemented in <a class="el" href="a00698.html#a3ba44434638d634a853b4e8e7f45de65">osg::Sequence</a>, <a class="el" href="a00852.html#a6bdf6e21cbf1819de7ea8b8ff5515713">osg::Switch</a>, and <a class="el" href="a00486.html#a0d92a20386388dacf69cfd1afd3dc3f6">osgSim::MultiSwitch</a>.</p>

</div>
</div>
<a class="anchor" id="a3c91554838f06c77fdc1c88ebe3487e1"></a><!-- doxytag: member="osg::Group::META_Node" ref="a3c91554838f06c77fdc1c88ebe3487e1" args="(osg, Group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osg::Group::META_Node </td>
          <td>(</td>
          <td class="paramtype">osg&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00338.html">Group</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="add2ef7fed87eb083a46776e122b9991f"></a><!-- doxytag: member="osg::Group::releaseGLObjects" ref="add2ef7fed87eb083a46776e122b9991f" args="(osg::State *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void osg::Group::releaseGLObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00745.html">osg::State</a> *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If <a class="el" href="a00745.html" title="Encapsulates the current applied OpenGL modes, attributes and vertex arrays settings, implements lazy state updating and provides accessors for querying the current state.">State</a> is non-zero, this function releases any associated OpenGL objects for the specified graphics context. </p>
<p>Otherwise, releases OpenGL objects for all graphics contexts. </p>

<p>Reimplemented from <a class="el" href="a00491.html#ad42811ad450626b5921aad11543cbf4c">osg::Node</a>.</p>

<p>Reimplemented in <a class="el" href="a00511.html#ae17d458a44555c1fafa4da3aae1df03e">osg::OcclusionQueryNode</a>, and <a class="el" href="a00533.html#a309d193faf7bc801e667051442bb7163">osgSim::OverlayNode</a>.</p>

</div>
</div>
<a class="anchor" id="aadb5f67516d3dbc3a21a6137171d8719"></a><!-- doxytag: member="osg::Group::removeChild" ref="aadb5f67516d3dbc3a21a6137171d8719" args="(unsigned int pos, unsigned int numChildrenToRemove=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osg::Group::removeChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>numChildrenToRemove</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> from <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>. </p>
<p>If <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is contained in <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a> then remove it from the child list, decrement its reference count, and dirty the bounding sphere to force it to recompute on next <a class="el" href="a00491.html#a1467f2ad703474ad37a236f87dee1f3a" title="Get the bounding sphere of node.">getBound()</a> and return true for success. If <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is not found then return false and do not change the reference count of the <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a>. Note, do not override, only override removeChildren(,) is required. </p>

</div>
</div>
<a class="anchor" id="a799af18caae45018d77d53c7520b3c1d"></a><!-- doxytag: member="osg::Group::removeChild" ref="a799af18caae45018d77d53c7520b3c1d" args="(Node *child)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osg::Group::removeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00491.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> from <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>. </p>
<p>If <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is contained in <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a> then remove it from the child list, decrement its reference count, and dirty the bounding sphere to force it to recompute on next <a class="el" href="a00491.html#a1467f2ad703474ad37a236f87dee1f3a" title="Get the bounding sphere of node.">getBound()</a> and return true for success. If <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is not found then return false and do not change the reference count of the <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a>. Note, do not override, only override removeChildren(,) is required. </p>

<p>Reimplemented in <a class="el" href="a00698.html#ac7c337657834272b5d3bf900509d14f4">osg::Sequence</a>, and <a class="el" href="a00486.html#a48d57feae9fbc86ae52b5727c6e115d8">osgSim::MultiSwitch</a>.</p>

</div>
</div>
<a class="anchor" id="a1bf3c672b6cf9438b252dc73c09f6275"></a><!-- doxytag: member="osg::Group::removeChildren" ref="a1bf3c672b6cf9438b252dc73c09f6275" args="(unsigned int pos, unsigned int numChildrenToRemove)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool osg::Group::removeChildren </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>numChildrenToRemove</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove children from <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>. </p>
<p>Note, must be override by subclasses of <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a> which add per child attributes. </p>

<p>Reimplemented in <a class="el" href="a00451.html#a2c6d8021845f39d8806041d52560870f">osg::LOD</a>, <a class="el" href="a00534.html#af0ea334b479290f3ba96ed5e02c37702">osg::PagedLOD</a>, <a class="el" href="a00603.html#aa3e95b6f85ec46145d1d515927cd143b">osg::ProxyNode</a>, <a class="el" href="a00698.html#a0397e560ca7f810b0c1dd67d99f2f256">osg::Sequence</a>, and <a class="el" href="a00852.html#a2f7ed5f54e4b3f1cedefaa401c5b7abc">osg::Switch</a>.</p>

</div>
</div>
<a class="anchor" id="a35a06b4a55bda8c4084683000bc5f53b"></a><!-- doxytag: member="osg::Group::replaceChild" ref="a35a06b4a55bda8c4084683000bc5f53b" args="(Node *origChild, Node *newChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool osg::Group::replaceChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00491.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>origChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00491.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>newChild</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replace specified <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> with another <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a>. </p>
<p>Equivalent to setChild(getChildIndex(orignChild),node) See docs for setChild for further details on implementation. </p>

</div>
</div>
<a class="anchor" id="a4049ebe617e25b77f24001c86ca16f07"></a><!-- doxytag: member="osg::Group::resizeGLObjectBuffers" ref="a4049ebe617e25b77f24001c86ca16f07" args="(unsigned int maxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void osg::Group::resizeGLObjectBuffers </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>maxSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize any per context GLObject buffers to specified size. </p>

<p>Reimplemented from <a class="el" href="a00491.html#a573872f56780b6f8081673969cec664a">osg::Node</a>.</p>

<p>Reimplemented in <a class="el" href="a00533.html#ad72c519463e68ec87d9369f5705a18ba">osgSim::OverlayNode</a>.</p>

</div>
</div>
<a class="anchor" id="a2644540e4268f9f61b22b9a0fda99468"></a><!-- doxytag: member="osg::Group::setChild" ref="a2644540e4268f9f61b22b9a0fda99468" args="(unsigned int i, Node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool osg::Group::setChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00491.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set child node at position i. </p>
<p>Return true if set correctly, false on failure (if node==NULL || i is out of range). When Set can be successful applied, the algorithm is : decrement the reference count origNode and increment the reference count of newNode, and dirty the bounding sphere to force it to recompute on next <a class="el" href="a00491.html#a1467f2ad703474ad37a236f87dee1f3a" title="Get the bounding sphere of node.">getBound()</a> and return true. If origNode is not found then return false and do not add newNode. If newNode is NULL then return false and do not remove origNode. Also returns false if newChild is a Scene node. </p>

</div>
</div>
<a class="anchor" id="a6b86895eb8b3ab999cd6a46f5aaaae64"></a><!-- doxytag: member="osg::Group::setThreadSafeRefUnref" ref="a6b86895eb8b3ab999cd6a46f5aaaae64" args="(bool threadSafe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void osg::Group::setThreadSafeRefUnref </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>threadSafe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether to use a mutex to ensure <a class="el" href="a00629.html#acafcbbae9e9d8bfcbc811cc6c36d1cf4" title="Increment the reference count by one, indicating that this object has another pointer which is refere...">ref()</a> and <a class="el" href="a00629.html#a0ee3c1293cceac54bfaabe7c541bcb68" title="Decrement the reference count by one, indicating that a pointer to this object is referencing it...">unref()</a> are thread safe. </p>

<p>Reimplemented from <a class="el" href="a00491.html#aaf10384628ac00e159195d0853e03f5e">osg::Node</a>.</p>

<p>Reimplemented in <a class="el" href="a00434.html#a9a919a7b5eb8c8d34714903018b1f3e0">osg::LightSource</a>, <a class="el" href="a00894.html#a36e96e657117fced6a98dbe2b50afe05">osg::TexGenNode</a>, and <a class="el" href="a00533.html#afe693b2f38854da138754ccfa9214160">osgSim::OverlayNode</a>.</p>

</div>
</div>
<a class="anchor" id="a189db7193e544ac67947c982b39aa435"></a><!-- doxytag: member="osg::Group::traverse" ref="a189db7193e544ac67947c982b39aa435" args="(NodeVisitor &amp;nv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void osg::Group::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00497.html">NodeVisitor</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Traverse downwards : calls children's accept method with <a class="el" href="a00497.html" title="Visitor for type safe operations on osg::Nodes.">NodeVisitor</a>. </p>

<p>Reimplemented from <a class="el" href="a00491.html#a16f26e64a5dc77e55b2544388349e668">osg::Node</a>.</p>

<p>Reimplemented in <a class="el" href="a00451.html#af06ce5afa734713fa63d5d089e93570c">osg::LOD</a>, <a class="el" href="a00534.html#aee2db3f36c00be5c1139e87829ac2adc">osg::PagedLOD</a>, <a class="el" href="a00603.html#a142207d27c4ca8b5e6948bb4f96c60e3">osg::ProxyNode</a>, <a class="el" href="a00698.html#a20c6891a6f2710b215989876dd4f60c6">osg::Sequence</a>, <a class="el" href="a00852.html#a699892f8df89915cc0aed1bd312ca304">osg::Switch</a>, <a class="el" href="a00240.html#aceebb7f8d95c8531b4ed1fe27b45a8f3">osgFX::Effect</a>, <a class="el" href="a00706.html#a9fa725b3c97333e4456c428fb97698d4">osgShadow::ShadowedScene</a>, <a class="el" href="a00213.html#a06021de2626cc732ad15fb5f32d20f3a">osgSim::DOFTransform</a>, <a class="el" href="a00363.html#a119f402ecb007df41af07885b2dd6862">osgSim::Impostor</a>, <a class="el" href="a00486.html#a5d8aad9fddc424ead69cd847feec41f9">osgSim::MultiSwitch</a>, <a class="el" href="a00533.html#ab252c61ad690cfd2808ddfcd920c4cea">osgSim::OverlayNode</a>, <a class="el" href="a01102.html#ab78fdffc92337f998a34be8f57d9f508">osgSim::VisibilityGroup</a>, <a class="el" href="a00881.html#a7753bd2e094bf50d35d127770f301d08">osgTerrain::Terrain</a>, <a class="el" href="a00884.html#a825c985b48aa7e01f68103c8bc8bec6f">osgTerrain::TerrainTile</a>, <a class="el" href="a01105.html#a6afa16b46ace233a7d82db91b8fa7e6d">osgVolume::Volume</a>, and <a class="el" href="a01107.html#ac94975ae770d9c4876e8d011b0d48752">osgVolume::VolumeTile</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ad046a9d7384b5183d42fc36ef32433dd"></a><!-- doxytag: member="osg::Group::_children" ref="ad046a9d7384b5183d42fc36ef32433dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01635.html#a42930b9d8d4f107bf147a3e438aa1654">NodeList</a> <a class="el" href="a00338.html#ad046a9d7384b5183d42fc36ef32433dd">osg::Group::_children</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>osg/<a class="el" href="a01194.html">Group</a></li>
</ul>
</div>
<hr>
<table border="0"><tr><td>
  <img src="osg32-32.png" alt="osg logo" />
</td><td>
  <address><small>Generated at Thu Jun 9 2011 16:37:15 for the <a href="http://www.openscenegraph.org/">OpenSceneGraph</a>
by <a href="http://www.doxygen.org">doxygen</a> 1.7.1.</small></address>
<!-- Dimitri van Heesch's e-mail address removed, lest he get messages on the OpenSceneGraph -->
</td></tr></table>
</body>
</html>
