<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenSceneGraph: osg::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="a01635.html">osg</a>      </li>
      <li><a class="el" href="a00491.html">osg::Node</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>osg::Node Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="osg::Node" --><!-- doxytag: inherits="osg::Object" -->
<p>Base class for all internal nodes in the scene graph.  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for osg::Node:</div>
<div class="dyncontent">
<div class="center"><img src="a02142.png" border="0" usemap="#osg_1_1Node_inherit__map" alt="Inheritance graph"/></div>
<map name="osg_1_1Node_inherit__map" id="osg_1_1Node_inherit__map">
<area shape="rect" id="node7" href="a00311.html" title="A Geode is a &quot;geometry node&quot;, that is, a leaf node on the scene graph that can have &quot;r..." alt="" coords="509,165,597,195"/><area shape="rect" id="node21" href="a00338.html" title="General group node which maintains a list of children." alt="" coords="511,965,596,995"/><area shape="rect" id="node87" href="a00542.html" title="A common base interface for those classes which need to do something on particles." alt="" coords="456,1311,651,1342"/><area shape="rect" id="node93" href="a00544.html" title="A useful node class for updating particle systems automatically." alt="" coords="440,1365,667,1395"/><area shape="rect" id="node95" href="a00576.html" title="osgParticle::PrecipitationEffect" alt="" coords="453,1418,653,1449"/><area shape="rect" id="node97" href="a00432.html" title="osgSim::LightPointNode" alt="" coords="473,1471,633,1502"/><area shape="rect" id="node2" href="a00501.html" title="Base class/standard interface for objects which require IO support, cloning and reference counting..." alt="" coords="172,1338,260,1369"/><area shape="rect" id="node4" href="a00629.html" title="Base class from providing referencing counted objects." alt="" coords="5,1338,123,1369"/><area shape="rect" id="node9" href="a00056.html" title="Billboard is a derived form of Geode that orients its osg::Drawable children to face the eye point..." alt="" coords="761,5,863,35"/><area shape="rect" id="node11" href="a00675.html" title="A ScalarBar is an osg::Geode to render a colored bar representing a range of scalars." alt="" coords="747,58,877,89"/><area shape="rect" id="node13" href="a00735.html" title="A SphereSegment is a Geode to represent an portion of a sphere (potentially the whole sphere)..." alt="" coords="729,111,895,142"/><area shape="rect" id="node15" href="a00074.html" title="Convinience class that provides a interactive quad that can be placed directly in the scene..." alt="" coords="743,165,881,195"/><area shape="rect" id="node17" href="a00546.html" title="Convinience class that provides a interactive quad that can be placed directly in the scene..." alt="" coords="737,218,887,249"/><area shape="rect" id="node19" href="a01103.html" title="Convinience Vnc Client class that provides a interactive quad that can be placed directly in the scen..." alt="" coords="739,271,885,302"/><area shape="rect" id="node23" href="a00104.html" title="A Group node for clearing the color and depth buffers." alt="" coords="757,325,867,355"/><area shape="rect" id="node25" href="a00105.html" title="Node for defining the position of ClipPlanes in the scene." alt="" coords="761,378,863,409"/><area shape="rect" id="node27" href="a00168.html" title="CoordinateSystem encapsulate the coordinate system that is associated with objects in a scene..." alt="" coords="719,431,905,462"/><area shape="rect" id="node29" href="a00434.html" title="Leaf Node for defining a light in the scene." alt="" coords="752,485,872,515"/><area shape="rect" id="node31" href="a00451.html" title="LOD &#45; Level Of Detail group node which allows switching between children depending on distance from e..." alt="" coords="775,538,849,569"/><area shape="rect" id="node37" href="a00510.html" title="OccluderNode is a Group node which allows OccluderNodeing between children." alt="" coords="745,591,879,622"/><area shape="rect" id="node39" href="a00511.html" title="osg::OcclusionQueryNode" alt="" coords="725,645,899,675"/><area shape="rect" id="node41" href="a00583.html" title="Projection nodes set up the frustum/orthographic projection used when rendering the scene..." alt="" coords="757,698,867,729"/><area shape="rect" id="node43" href="a00603.html" title="ProxyNode." alt="" coords="755,751,869,782"/><area shape="rect" id="node45" href="a00698.html" title="Sequence is a Group node which allows automatic, time based switching between children." alt="" coords="757,805,867,835"/><area shape="rect" id="node47" href="a00852.html" title="Switch is a Group node that allows switching between children." alt="" coords="767,858,857,889"/><area shape="rect" id="node51" href="a00894.html" title="Node for defining the position of TexGen in the scene." alt="" coords="749,911,875,942"/><area shape="rect" id="node53" href="a00928.html" title="A Transform is a group node for which all children are transformed by a 4x4 matrix." alt="" coords="757,965,867,995"/><area shape="rect" id="node65" href="a00240.html" title="The base class for special effects." alt="" coords="761,1018,863,1049"/><area shape="rect" id="node67" href="a00487.html" title="This node provides control over the which texture units are active and the blending weighting between..." alt="" coords="723,1071,901,1102"/><area shape="rect" id="node69" href="a00541.html" title="osgParticle::ParticleEffect" alt="" coords="727,1125,897,1155"/><area shape="rect" id="node71" href="a00706.html" title="ShadowedScene provides a mechansim for decorating a scene that the needs to have shadows cast upon it..." alt="" coords="715,1178,909,1209"/><area shape="rect" id="node73" href="a00486.html" title="MultiSwitch is a Group node which allows switching between sets of selected children." alt="" coords="741,1231,883,1262"/><area shape="rect" id="node75" href="a00533.html" title="OverlayNode is for creating texture overlays on scenes, with the overlay texture being generated by p..." alt="" coords="737,1285,887,1315"/><area shape="rect" id="node77" href="a01102.html" title="VisibilityGroup renders (traverses) it&#39;s children only when the camera is inside a specified visi..." alt="" coords="733,1338,891,1369"/><area shape="rect" id="node79" href="a00881.html" title="Terrain provides a framework for loosely coupling height field data with height rendering algorithms..." alt="" coords="748,1391,876,1422"/><area shape="rect" id="node81" href="a00884.html" title="Terrain provides a framework for loosely coupling height field data with height rendering algorithms..." alt="" coords="737,1445,887,1475"/><area shape="rect" id="node83" href="a01105.html" title="Volume provides a framework for loosely coupling 3d image VolumeTile&#39;s with volume algorithms..." alt="" coords="744,1498,880,1529"/><area shape="rect" id="node85" href="a01107.html" title="VolumeTile provides a framework for loosely coupling 3d image data with rendering algorithms..." alt="" coords="733,1551,891,1582"/><area shape="rect" id="node33" href="a00534.html" title="PagedLOD." alt="" coords="1001,511,1113,542"/><area shape="rect" id="node35" href="a00363.html" title="Impostor &#45; is a form of Level Of Detail group node which allows both switching between children depen..." alt="" coords="995,565,1120,595"/><area shape="rect" id="node49" href="a01115.html" title="osgWidget::WindowManager" alt="" coords="964,831,1151,862"/><area shape="rect" id="node55" href="a00045.html" title="AutoTransform is a derived form of Transform that automatically scales or rotates to keep its childre..." alt="" coords="989,885,1125,915"/><area shape="rect" id="node57" href="a00087.html" title="Camera &#45; is a subclass of Transform which represents encapsulates the settings of a Camera..." alt="" coords="1009,938,1105,969"/><area shape="rect" id="node59" href="a00091.html" title="CameraView &#45; is a Transform that is used to specify camera views from within the scene graph..." alt="" coords="996,991,1119,1022"/><area shape="rect" id="node61" href="a00464.html" title="MatrixTransform &#45; is a subclass of Transform which has an osg::Matrix which represents a 4x4 transfor..." alt="" coords="985,1045,1129,1075"/><area shape="rect" id="node63" href="a00573.html" title="PositionAttitudeTransform &#45; is a Transform." alt="" coords="957,1098,1157,1129"/><area shape="rect" id="node89" href="a00247.html" title="An abstract base class for particle emitters." alt="" coords="745,1605,879,1635"/><area shape="rect" id="node91" href="a00581.html" title="An abstract ParticleProcessor descendant for modifying particles &quot;on the fly&quot; during the cu..." alt="" coords="741,1658,883,1689"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="a02143.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html">ComputeBoundingSphereCallback</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback to allow users to override the default computation of bounding volume.  <a href="a00133.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="a00338.html">Group</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a43a8294c266bdedcb63d0d3db59ac882">ParentList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A vector of <a class="el" href="a00338.html" title="General group node which maintains a list of children.">osg::Group</a> pointers which is used to store the parent(s) of node.  <a href="#a43a8294c266bdedcb63d0d3db59ac882"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ab973b9ec7cebae692032e1038d951e23">NodeMask</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a7f7cfbdff46aa5041d5cd1fb20dc43a2">DescriptionList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A vector of std::string's which are used to describe the object.  <a href="#a7f7cfbdff46aa5041d5cd1fb20dc43a2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a70c42f604012b95f598a4f6235e40f9e">Node</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a node.  <a href="#a70c42f604012b95f598a4f6235e40f9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#af4bca9aefd1eaaa5f345089a92676295">Node</a> (const <a class="el" href="a00491.html">Node</a> &amp;, const <a class="el" href="a00169.html">CopyOp</a> &amp;copyop=CopyOp::SHALLOW_COPY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor using <a class="el" href="a00169.html" title="Copy Op(erator) used to control whether shallow or deep copy is used during copy construction and clo...">CopyOp</a> to manage deep vs shallow copy.  <a href="#af4bca9aefd1eaaa5f345089a92676295"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00501.html">Object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a4b52ccde0045dadeea60c49d6963eb7a">cloneType</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">clone an object of the same type as the node.  <a href="#a4b52ccde0045dadeea60c49d6963eb7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00501.html">Object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a110e4fb1ad04efda54b31c03f69a9752">clone</a> (const <a class="el" href="a00169.html">CopyOp</a> &amp;copyop) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return a clone of a node, with Object* return type.  <a href="#a110e4fb1ad04efda54b31c03f69a9752"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a3e31528058dae0a90b113adee3653ecc">isSameKindAs</a> (const <a class="el" href="a00501.html">Object</a> *obj) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return true if this and obj are of the same kind of object.  <a href="#a3e31528058dae0a90b113adee3653ecc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a40919ed617cdf7238ad99e5d2f0a330f">libraryName</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the name of the node's library.  <a href="#a40919ed617cdf7238ad99e5d2f0a330f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#accf4145d104408ed2337166df77aa404">className</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the name of the node's class type.  <a href="#accf4145d104408ed2337166df77aa404"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00338.html">Group</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a5685f61aec39a1df350b2e707cea05cc">asGroup</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert 'this' into a <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>, otherwise return 0.  <a href="#a5685f61aec39a1df350b2e707cea05cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="a00338.html">Group</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#aad6973a39010d3c44e91301204680df5">asGroup</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert 'const this' into a const <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>, otherwise return 0.  <a href="#aad6973a39010d3c44e91301204680df5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00928.html">Transform</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#afc1876e851817deae067a33ea90773c3">asTransform</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert 'this' into a <a class="el" href="a00928.html" title="A Transform is a group node for which all children are transformed by a 4x4 matrix.">Transform</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00928.html" title="A Transform is a group node for which all children are transformed by a 4x4 matrix.">Transform</a>, otherwise return 0.  <a href="#afc1876e851817deae067a33ea90773c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="a00928.html">Transform</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a9ae26553ceb82e99417a8c73c00fe3b0">asTransform</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert 'const this' into a const <a class="el" href="a00928.html" title="A Transform is a group node for which all children are transformed by a 4x4 matrix.">Transform</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00928.html" title="A Transform is a group node for which all children are transformed by a 4x4 matrix.">Transform</a>, otherwise return 0.  <a href="#a9ae26553ceb82e99417a8c73c00fe3b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00852.html">Switch</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#af2deff597acc55362d0c4d102715f731">asSwitch</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert 'this' into a <a class="el" href="a00852.html" title="Switch is a Group node that allows switching between children.">Switch</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00852.html" title="Switch is a Group node that allows switching between children.">Switch</a>, otherwise return 0.  <a href="#af2deff597acc55362d0c4d102715f731"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="a00852.html">Switch</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ac07b3226938539c7853ea5eab390dc7a">asSwitch</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert 'const this' into a const <a class="el" href="a00852.html" title="Switch is a Group node that allows switching between children.">Switch</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00852.html" title="Switch is a Group node that allows switching between children.">Switch</a>, otherwise return 0.  <a href="#ac07b3226938539c7853ea5eab390dc7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00311.html">Geode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a03774d04fecf3b82aa3622660ce1533b">asGeode</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert 'this' into a <a class="el" href="a00311.html" title="A Geode is a &quot;geometry node&quot;, that is, a leaf node on the scene graph that can have &quot;r...">Geode</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00311.html" title="A Geode is a &quot;geometry node&quot;, that is, a leaf node on the scene graph that can have &quot;r...">Geode</a>, otherwise return 0.  <a href="#a03774d04fecf3b82aa3622660ce1533b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="a00311.html">Geode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a34d935a372b64039daaca30440622201">asGeode</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert 'const this' into a const <a class="el" href="a00311.html" title="A Geode is a &quot;geometry node&quot;, that is, a leaf node on the scene graph that can have &quot;r...">Geode</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00311.html" title="A Geode is a &quot;geometry node&quot;, that is, a leaf node on the scene graph that can have &quot;r...">Geode</a>, otherwise return 0.  <a href="#a34d935a372b64039daaca30440622201"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ad73a26159e0fb27ac031fdb1cf278908">accept</a> (<a class="el" href="a00497.html">NodeVisitor</a> &amp;nv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visitor Pattern : calls the apply method of a <a class="el" href="a00497.html" title="Visitor for type safe operations on osg::Nodes.">NodeVisitor</a> with this node's type.  <a href="#ad73a26159e0fb27ac031fdb1cf278908"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ae54d13b12621d8718bf19e837cfe5b64">ascend</a> (<a class="el" href="a00497.html">NodeVisitor</a> &amp;nv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traverse upwards : calls parents' accept method with <a class="el" href="a00497.html" title="Visitor for type safe operations on osg::Nodes.">NodeVisitor</a>.  <a href="#ae54d13b12621d8718bf19e837cfe5b64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a16f26e64a5dc77e55b2544388349e668">traverse</a> (<a class="el" href="a00497.html">NodeVisitor</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traverse downwards : calls children's accept method with <a class="el" href="a00497.html" title="Visitor for type safe operations on osg::Nodes.">NodeVisitor</a>.  <a href="#a16f26e64a5dc77e55b2544388349e668"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00491.html#a43a8294c266bdedcb63d0d3db59ac882">ParentList</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a8325cc82518522125eca8d35924806ec">getParents</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the parent list of node.  <a href="#a8325cc82518522125eca8d35924806ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00491.html#a43a8294c266bdedcb63d0d3db59ac882">ParentList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ab004bf059235681112a5d4048f83b902">getParents</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the a copy of parent list of node.  <a href="#ab004bf059235681112a5d4048f83b902"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00338.html">Group</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#afa64f11832262a6ddb3824b9afbdddc9">getParent</a> (unsigned int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00338.html">Group</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#adafb5475dc066724a18eaea8bba7b27f">getParent</a> (unsigned int i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a single const parent of node.  <a href="#adafb5475dc066724a18eaea8bba7b27f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a7e301ad455a59ead4b9111a21a97bf6f">getNumParents</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of parents of node.  <a href="#a7e301ad455a59ead4b9111a21a97bf6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01635.html#a65ddcb6ba8f49d0b40812a3cf4122246">NodePathList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a189e62483ac0359c811917ea01f24ac4">getParentalNodePaths</a> (<a class="el" href="a00491.html">osg::Node</a> *haltTraversalAtNode=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of node paths parent paths.  <a href="#a189e62483ac0359c811917ea01f24ac4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01635.html#a22d1eac701d86ccc45b1e9c1e676d3e2">MatrixList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a4db296a84c57af8b2297c175007df4c7">getWorldMatrices</a> (const <a class="el" href="a00491.html">osg::Node</a> *haltTraversalAtNode=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of matrices that transform this node from local coordinates to world coordinates.  <a href="#a4db296a84c57af8b2297c175007df4c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a7fe444c26b80499bbd19ab3965dd0df3">setUpdateCallback</a> (<a class="el" href="a00493.html">NodeCallback</a> *nc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set update node callback, called during update traversal.  <a href="#a7fe444c26b80499bbd19ab3965dd0df3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ac51f7b1f5636cc1d671d2ae87855c7bc">getUpdateCallback</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get update node callback, called during update traversal.  <a href="#ac51f7b1f5636cc1d671d2ae87855c7bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a36ee6471fa5d47a3cf02c0f95a8219dd">getUpdateCallback</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get const update node callback, called during update traversal.  <a href="#a36ee6471fa5d47a3cf02c0f95a8219dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a7f19232e88e1e17c8394245537c747fb">addUpdateCallback</a> (<a class="el" href="a00493.html">NodeCallback</a> *nc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method that sets the update callback of the node if it doesn't exist, or nest it into the existing one.  <a href="#a7f19232e88e1e17c8394245537c747fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a2cfeff242a6edef283ce39eb698751e7">removeUpdateCallback</a> (<a class="el" href="a00493.html">NodeCallback</a> *nc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method that removes a given callback from a node, even if that callback is nested.  <a href="#a2cfeff242a6edef283ce39eb698751e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a3135de114532ef9a62c59b507411bd59">getNumChildrenRequiringUpdateTraversal</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of Children of this node which require Update traversal, since they have an Update Callback attached to them or their children.  <a href="#a3135de114532ef9a62c59b507411bd59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#aa1c317a8bdb9759f6fd85e4a256d72b7">setEventCallback</a> (<a class="el" href="a00493.html">NodeCallback</a> *nc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set event node callback, called during event traversal.  <a href="#aa1c317a8bdb9759f6fd85e4a256d72b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#aca44e8707d023fcbc6af05ea3e17c872">getEventCallback</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get event node callback, called during event traversal.  <a href="#aca44e8707d023fcbc6af05ea3e17c872"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a08fd9ffa53bd8f0bcaf6b7c292bd1312">getEventCallback</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get const event node callback, called during event traversal.  <a href="#a08fd9ffa53bd8f0bcaf6b7c292bd1312"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#abf10f3920e38b2c7a24b46aad9d4b9b5">addEventCallback</a> (<a class="el" href="a00493.html">NodeCallback</a> *nc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method that sets the event callback of the node if it doesn't exist, or nest it into the existing one.  <a href="#abf10f3920e38b2c7a24b46aad9d4b9b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a003e329a107abd6b660a1a58d86f7846">removeEventCallback</a> (<a class="el" href="a00493.html">NodeCallback</a> *nc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method that removes a given callback from a node, even if that callback is nested.  <a href="#a003e329a107abd6b660a1a58d86f7846"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#aa1ca13749e35228ff6f7fbbf8f9b1f99">getNumChildrenRequiringEventTraversal</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of Children of this node which require Event traversal, since they have an Event Callback attached to them or their children.  <a href="#aa1ca13749e35228ff6f7fbbf8f9b1f99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a8fcdb41e2019787b597a9e3f651696ae">setCullCallback</a> (<a class="el" href="a00493.html">NodeCallback</a> *nc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set cull node callback, called during cull traversal.  <a href="#a8fcdb41e2019787b597a9e3f651696ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a8be56b8cd46661f9dd5bbe151edf7299">getCullCallback</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get cull node callback, called during cull traversal.  <a href="#a8be56b8cd46661f9dd5bbe151edf7299"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a7316d559c4f5eb9cebda5a65c6e3433a">getCullCallback</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get const cull node callback, called during cull traversal.  <a href="#a7316d559c4f5eb9cebda5a65c6e3433a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#aced2f541d3d5c32d73bbcf9d8d7e8126">addCullCallback</a> (<a class="el" href="a00493.html">NodeCallback</a> *nc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method that sets the cull callback of the node if it doesn't exist, or nest it into the existing one.  <a href="#aced2f541d3d5c32d73bbcf9d8d7e8126"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ac7fecd76b2f869d7ae427c03380a4058">removeCullCallback</a> (<a class="el" href="a00493.html">NodeCallback</a> *nc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method that removes a given callback from a node, even if that callback is nested.  <a href="#ac7fecd76b2f869d7ae427c03380a4058"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a7a5b00fb04dd0352a3ba76f7bf0a9e00">setCullingActive</a> (bool active)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the view frustum/small feature culling of this node to be active or inactive.  <a href="#a7a5b00fb04dd0352a3ba76f7bf0a9e00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#afbb5bbdc81694fb89b96c292bd30e810">getCullingActive</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the view frustum/small feature _cullingActive flag for this node.  <a href="#afbb5bbdc81694fb89b96c292bd30e810"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a998231a2ce906d5ee53bd0629e857365">getNumChildrenWithCullingDisabled</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of Children of this node which have culling disabled.  <a href="#a998231a2ce906d5ee53bd0629e857365"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#add3db83625ea19747332ef780685eb72">isCullingActive</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if this node can be culled by view frustum, occlusion or small feature culling during the cull traversal.  <a href="#add3db83625ea19747332ef780685eb72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a70012fc9e8c642bff54f6b87a1eff4e1">getNumChildrenWithOccluderNodes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of Children of this node which are or have OccluderNode's.  <a href="#a70012fc9e8c642bff54f6b87a1eff4e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a4f3cb1001ed1187e15e40ae1b9e17139">containsOccluderNodes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return true if this node is an <a class="el" href="a00510.html" title="OccluderNode is a Group node which allows OccluderNodeing between children.">OccluderNode</a> or the subgraph below this node are OccluderNodes.  <a href="#a4f3cb1001ed1187e15e40ae1b9e17139"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a93db475215310e88ddd9c717b7ed623e">setNodeMask</a> (<a class="el" href="a00491.html#ab973b9ec7cebae692032e1038d951e23">NodeMask</a> nm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the node mask.  <a href="#a93db475215310e88ddd9c717b7ed623e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00491.html#ab973b9ec7cebae692032e1038d951e23">NodeMask</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a38566f0dc432e18aa77ad8fc70e48da2">getNodeMask</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the node Mask.  <a href="#a38566f0dc432e18aa77ad8fc70e48da2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#aae20f94cd51d44bd463e7280e52b4edc">setDescriptions</a> (const <a class="el" href="a00491.html#a7f7cfbdff46aa5041d5cd1fb20dc43a2">DescriptionList</a> &amp;descriptions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the description list of the node.  <a href="#aae20f94cd51d44bd463e7280e52b4edc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00491.html#a7f7cfbdff46aa5041d5cd1fb20dc43a2">DescriptionList</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a37b2c00d68c75b583e2d7e5efaa40db4">getDescriptions</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the description list of the node.  <a href="#a37b2c00d68c75b583e2d7e5efaa40db4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00491.html#a7f7cfbdff46aa5041d5cd1fb20dc43a2">DescriptionList</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a7fca2d83852afa6027abd7cec6ff2ef5">getDescriptions</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the const description list of the const node.  <a href="#a7fca2d83852afa6027abd7cec6ff2ef5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a6487f1d4879871c6e8422380491151f5">getDescription</a> (unsigned int i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a single const description of the const node.  <a href="#a6487f1d4879871c6e8422380491151f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#aad08ff52e592b8620fa5346bcdf4d16b">getDescription</a> (unsigned int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a single description of the node.  <a href="#aad08ff52e592b8620fa5346bcdf4d16b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#af46335dfd98ea6a89192ab4ffebb3761">getNumDescriptions</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of descriptions of the node.  <a href="#af46335dfd98ea6a89192ab4ffebb3761"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a13005a77022880b0845b8c1fefbb45f2">addDescription</a> (const std::string &amp;desc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a description string to the node.  <a href="#a13005a77022880b0845b8c1fefbb45f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ad1948eda88d921795dde2ad326e82236">setStateSet</a> (<a class="el" href="a00749.html">osg::StateSet</a> *stateset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the node's <a class="el" href="a00749.html" title="Stores a set of modes and attributes which represent a set of OpenGL state.">StateSet</a>.  <a href="#ad1948eda88d921795dde2ad326e82236"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00749.html">osg::StateSet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a1d1a3831e239372dc743321226856e39">getOrCreateStateSet</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the node's <a class="el" href="a00749.html" title="Stores a set of modes and attributes which represent a set of OpenGL state.">StateSet</a>, if one does not already exist create it set the node and return the newly created <a class="el" href="a00749.html" title="Stores a set of modes and attributes which represent a set of OpenGL state.">StateSet</a>.  <a href="#a1d1a3831e239372dc743321226856e39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00749.html">osg::StateSet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a476fe31b2d9b0f591bd1e8377ab4b586">getStateSet</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the node's <a class="el" href="a00749.html" title="Stores a set of modes and attributes which represent a set of OpenGL state.">StateSet</a>.  <a href="#a476fe31b2d9b0f591bd1e8377ab4b586"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00749.html">osg::StateSet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#acbb0db6111bccbf9327a4d15a5cf6936">getStateSet</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the node's const <a class="el" href="a00749.html" title="Stores a set of modes and attributes which represent a set of OpenGL state.">StateSet</a>.  <a href="#acbb0db6111bccbf9327a4d15a5cf6936"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a743b4b12bde43d75eae673db804fb09d">setInitialBound</a> (const <a class="el" href="a00070.html">osg::BoundingSphere</a> &amp;bsphere)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the initial bounding volume to use when computing the overall bounding volume.  <a href="#a743b4b12bde43d75eae673db804fb09d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00070.html">BoundingSphere</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a36660a84e8ecb270deecc36c9b4ab3ca">getInitialBound</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the initial bounding volume to use when computing the overall bounding volume.  <a href="#a36660a84e8ecb270deecc36c9b4ab3ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ae0c87d5abfa0b64bca79600b77e0f7ba">dirtyBound</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark this node's bounding sphere dirty.  <a href="#ae0c87d5abfa0b64bca79600b77e0f7ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00070.html">BoundingSphere</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a1467f2ad703474ad37a236f87dee1f3a">getBound</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the bounding sphere of node.  <a href="#a1467f2ad703474ad37a236f87dee1f3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00070.html">BoundingSphere</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ac3098a0de0b680b7bf1ebd3547f09cce">computeBound</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the bounding sphere around Node's geometry or children.  <a href="#ac3098a0de0b680b7bf1ebd3547f09cce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a7be58d053003c303c036d9490e1e7348">setComputeBoundingSphereCallback</a> (<a class="el" href="a00133.html">ComputeBoundingSphereCallback</a> *callback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the compute bound callback to override the default computeBound.  <a href="#a7be58d053003c303c036d9490e1e7348"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00133.html">ComputeBoundingSphereCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a81c706c09c92ac530be833d70077c614">getComputeBoundingSphereCallback</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the compute bound callback.  <a href="#a81c706c09c92ac530be833d70077c614"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="a00133.html">ComputeBoundingSphereCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a786682fb9b3496252525abba4a674a57">getComputeBoundingSphereCallback</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the const compute bound callback.  <a href="#a786682fb9b3496252525abba4a674a57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#aaf10384628ac00e159195d0853e03f5e">setThreadSafeRefUnref</a> (bool threadSafe)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to use a mutex to ensure <a class="el" href="a00629.html#acafcbbae9e9d8bfcbc811cc6c36d1cf4" title="Increment the reference count by one, indicating that this object has another pointer which is refere...">ref()</a> and <a class="el" href="a00629.html#a0ee3c1293cceac54bfaabe7c541bcb68" title="Decrement the reference count by one, indicating that a pointer to this object is referencing it...">unref()</a> are thread safe.  <a href="#aaf10384628ac00e159195d0853e03f5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a573872f56780b6f8081673969cec664a">resizeGLObjectBuffers</a> (unsigned int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize any per context GLObject buffers to specified size.  <a href="#a573872f56780b6f8081673969cec664a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ad42811ad450626b5921aad11543cbf4c">releaseGLObjects</a> (<a class="el" href="a00745.html">osg::State</a> *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <a class="el" href="a00745.html" title="Encapsulates the current applied OpenGL modes, attributes and vertex arrays settings, implements lazy state updating and provides accessors for querying the current state.">State</a> is non-zero, this function releases any associated OpenGL objects for the specified graphics context.  <a href="#ad42811ad450626b5921aad11543cbf4c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a79e1d2cdbb4472ee66a5725fcca3e859">~Node</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> destructor.  <a href="#a79e1d2cdbb4472ee66a5725fcca3e859"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a6fc20ef75ed36c397bf5d745661e8c92">addParent</a> (<a class="el" href="a00338.html">osg::Group</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a3185b5fb0ece1025a4d3d7a6bca788eb">removeParent</a> (<a class="el" href="a00338.html">osg::Group</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a25069f7c69723629bd725796345a8b00">setNumChildrenRequiringUpdateTraversal</a> (unsigned int num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a433055a290d0d4d94e5e483206303683">setNumChildrenRequiringEventTraversal</a> (unsigned int num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ab4e08b4fe76c2a3e611b775571005ab1">setNumChildrenWithCullingDisabled</a> (unsigned int num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a26ee64ad1f6496faa61e6cbf4ce7de75">setNumChildrenWithOccluderNodes</a> (unsigned int num)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html">BoundingSphere</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#aa9571664b6037022c4aa4cac01c1eab7">_initialBound</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00626.html">ref_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="a00133.html">ComputeBoundingSphereCallback</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a1978ffb819195d9e18e354fd315a9394">_computeBoundCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html">BoundingSphere</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#afaa1be92dabff7b02aa71d8f9fad41f4">_boundingSphere</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#af4b630e69630574f2396306530150222">_boundingSphereComputed</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00491.html#a43a8294c266bdedcb63d0d3db59ac882">ParentList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#af7eed72246d7bf9c458d87ae3081ca97">_parents</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00626.html">ref_ptr</a>&lt; <a class="el" href="a00493.html">NodeCallback</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a9124934cb60d57b38cd5d52c782c6820">_updateCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a9a33ff52bb29a8e192c0c16718a929e6">_numChildrenRequiringUpdateTraversal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00626.html">ref_ptr</a>&lt; <a class="el" href="a00493.html">NodeCallback</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a28d484e71e9e7beacf2cdfb4c5cb20ab">_eventCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#afd484189b28d131fae2d1c09218df633">_numChildrenRequiringEventTraversal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00626.html">ref_ptr</a>&lt; <a class="el" href="a00493.html">NodeCallback</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a0b6bd1afdbe59668f0342d5ddb49b375">_cullCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a11da6726a72e15cb4ec3d8ca90baaefb">_cullingActive</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#aff0c649800ba69c0ed416ccc483f5b7e">_numChildrenWithCullingDisabled</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a134bdee33f86dad7aadfb737a1782aac">_numChildrenWithOccluderNodes</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00491.html#ab973b9ec7cebae692032e1038d951e23">NodeMask</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a25a4a53b16d140631c08ba568b7b48d1">_nodeMask</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00491.html#a7f7cfbdff46aa5041d5cd1fb20dc43a2">DescriptionList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ac0ad937258357dec411f22b9a4fbf2dc">_descriptions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00626.html">ref_ptr</a>&lt; <a class="el" href="a00749.html">StateSet</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a3e97127339b5704bf27ab1662613868a">_stateset</a></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a8c78c91a5b28f80a42253ce9a2f90d62">osg::Group</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#af7c3ee69924c55e0590e04f5d11abe93">osg::Drawable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#a7593955b51fad9f6836d9ffb2539181d">osg::StateSet</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Base class for all internal nodes in the scene graph. </p>
<p>Provides interface for most common node operations (Composite Pattern). </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a7f7cfbdff46aa5041d5cd1fb20dc43a2"></a><!-- doxytag: member="osg::Node::DescriptionList" ref="a7f7cfbdff46aa5041d5cd1fb20dc43a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;std::string&gt; <a class="el" href="a00491.html#a7f7cfbdff46aa5041d5cd1fb20dc43a2">osg::Node::DescriptionList</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A vector of std::string's which are used to describe the object. </p>

</div>
</div>
<a class="anchor" id="ab973b9ec7cebae692032e1038d951e23"></a><!-- doxytag: member="osg::Node::NodeMask" ref="ab973b9ec7cebae692032e1038d951e23" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="a00491.html#ab973b9ec7cebae692032e1038d951e23">osg::Node::NodeMask</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a43a8294c266bdedcb63d0d3db59ac882"></a><!-- doxytag: member="osg::Node::ParentList" ref="a43a8294c266bdedcb63d0d3db59ac882" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="a00338.html">Group</a>*&gt; <a class="el" href="a00491.html#a43a8294c266bdedcb63d0d3db59ac882">osg::Node::ParentList</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A vector of <a class="el" href="a00338.html" title="General group node which maintains a list of children.">osg::Group</a> pointers which is used to store the parent(s) of node. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a70c42f604012b95f598a4f6235e40f9e"></a><!-- doxytag: member="osg::Node::Node" ref="a70c42f604012b95f598a4f6235e40f9e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osg::Node::Node </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a node. </p>
<p>Initialize the parent list to empty, node name to "" and bounding sphere dirty flag to true. </p>

</div>
</div>
<a class="anchor" id="af4bca9aefd1eaaa5f345089a92676295"></a><!-- doxytag: member="osg::Node::Node" ref="af4bca9aefd1eaaa5f345089a92676295" args="(const Node &amp;, const CopyOp &amp;copyop=CopyOp::SHALLOW_COPY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osg::Node::Node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00491.html">Node</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00169.html">CopyOp</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyop</em> = <code>CopyOp::SHALLOW_COPY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor using <a class="el" href="a00169.html" title="Copy Op(erator) used to control whether shallow or deep copy is used during copy construction and clo...">CopyOp</a> to manage deep vs shallow copy. </p>

</div>
</div>
<a class="anchor" id="a79e1d2cdbb4472ee66a5725fcca3e859"></a><!-- doxytag: member="osg::Node::~Node" ref="a79e1d2cdbb4472ee66a5725fcca3e859" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual osg::Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> destructor. </p>
<p>Note, is protected so that Nodes cannot be deleted other than by being dereferenced and the reference count being zero (see <a class="el" href="a00629.html" title="Base class from providing referencing counted objects.">osg::Referenced</a>), preventing the deletion of nodes which are still in use. This also means that Nodes cannot be created on stack i.e <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> node will not compile, forcing all nodes to be created on the heap i.e Node* node = new <a class="el" href="a00491.html#a70c42f604012b95f598a4f6235e40f9e" title="Construct a node.">Node()</a>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad73a26159e0fb27ac031fdb1cf278908"></a><!-- doxytag: member="osg::Node::accept" ref="ad73a26159e0fb27ac031fdb1cf278908" args="(NodeVisitor &amp;nv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void osg::Node::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00497.html">NodeVisitor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Visitor Pattern : calls the apply method of a <a class="el" href="a00497.html" title="Visitor for type safe operations on osg::Nodes.">NodeVisitor</a> with this node's type. </p>

<p>Reimplemented in <a class="el" href="a00045.html#ace1db2d43daa0319d3943e96b632f613">osg::AutoTransform</a>, <a class="el" href="a00247.html#a1566c9a14694e0ee6d3fb364b63d7e16">osgParticle::Emitter</a>, <a class="el" href="a00541.html#acd7b7ba681a0453f4b978b5a7c14a4ce">osgParticle::ParticleEffect</a>, <a class="el" href="a00542.html#a5d0608077ee97ad6ea182f9f31fe7fd2">osgParticle::ParticleProcessor</a>, <a class="el" href="a00576.html#a9e03d8b33a60470df5695ac7be36ec3e">osgParticle::PrecipitationEffect</a>, and <a class="el" href="a00581.html#afcf509adf743ba9baf32dd86b287d2f9">osgParticle::Program</a>.</p>

<p>Referenced by <a class="el" href="a00640.html#a9c6774afede8334e5c4badc5d61622e5">osgDB::Registry::_buildKdTreeIfRequired()</a>, <a class="el" href="a00182.html#ad10b06fd35ed7a074addc812037948d7">osgUtil::CullVisitor::handle_cull_callbacks_and_accept()</a>, <a class="el" href="a00108.html#ad61b4540ebe43a56701646f3bcaaed7f">osg::CollectOccludersVisitor::handle_cull_callbacks_and_accept()</a>, and <a class="el" href="a00492.html#ab6771aad80ca7af01602e2387efb9342">osg::NodeAcceptOp::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="aced2f541d3d5c32d73bbcf9d8d7e8126"></a><!-- doxytag: member="osg::Node::addCullCallback" ref="aced2f541d3d5c32d73bbcf9d8d7e8126" args="(NodeCallback *nc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::addCullCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>nc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method that sets the cull callback of the node if it doesn't exist, or nest it into the existing one. </p>

<p>References <a class="el" href="a01163.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="a13005a77022880b0845b8c1fefbb45f2"></a><!-- doxytag: member="osg::Node::addDescription" ref="a13005a77022880b0845b8c1fefbb45f2" args="(const std::string &amp;desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::addDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a description string to the node. </p>

</div>
</div>
<a class="anchor" id="abf10f3920e38b2c7a24b46aad9d4b9b5"></a><!-- doxytag: member="osg::Node::addEventCallback" ref="abf10f3920e38b2c7a24b46aad9d4b9b5" args="(NodeCallback *nc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::addEventCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>nc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method that sets the event callback of the node if it doesn't exist, or nest it into the existing one. </p>

<p>References <a class="el" href="a01163.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="a6fc20ef75ed36c397bf5d745661e8c92"></a><!-- doxytag: member="osg::Node::addParent" ref="a6fc20ef75ed36c397bf5d745661e8c92" args="(osg::Group *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::addParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00338.html">osg::Group</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f19232e88e1e17c8394245537c747fb"></a><!-- doxytag: member="osg::Node::addUpdateCallback" ref="a7f19232e88e1e17c8394245537c747fb" args="(NodeCallback *nc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::addUpdateCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>nc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method that sets the update callback of the node if it doesn't exist, or nest it into the existing one. </p>

<p>References <a class="el" href="a01163.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="ae54d13b12621d8718bf19e837cfe5b64"></a><!-- doxytag: member="osg::Node::ascend" ref="ae54d13b12621d8718bf19e837cfe5b64" args="(NodeVisitor &amp;nv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void osg::Node::ascend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00497.html">NodeVisitor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Traverse upwards : calls parents' accept method with <a class="el" href="a00497.html" title="Visitor for type safe operations on osg::Nodes.">NodeVisitor</a>. </p>

<p>Referenced by <a class="el" href="a00497.html#a95e2e46371a099bc4bd6749c19aab029">osg::NodeVisitor::traverse()</a>.</p>

</div>
</div>
<a class="anchor" id="a03774d04fecf3b82aa3622660ce1533b"></a><!-- doxytag: member="osg::Node::asGeode" ref="a03774d04fecf3b82aa3622660ce1533b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00311.html">Geode</a>* osg::Node::asGeode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert 'this' into a <a class="el" href="a00311.html" title="A Geode is a &quot;geometry node&quot;, that is, a leaf node on the scene graph that can have &quot;r...">Geode</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00311.html" title="A Geode is a &quot;geometry node&quot;, that is, a leaf node on the scene graph that can have &quot;r...">Geode</a>, otherwise return 0. </p>
<p>Equivalent to dynamic_cast&lt;Geode*&gt;(this). </p>

<p>Reimplemented in <a class="el" href="a00311.html#a8f75419791d4fe71b7dae23c6f8964f5">osg::Geode</a>.</p>

</div>
</div>
<a class="anchor" id="a34d935a372b64039daaca30440622201"></a><!-- doxytag: member="osg::Node::asGeode" ref="a34d935a372b64039daaca30440622201" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="a00311.html">Geode</a>* osg::Node::asGeode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convert 'const this' into a const <a class="el" href="a00311.html" title="A Geode is a &quot;geometry node&quot;, that is, a leaf node on the scene graph that can have &quot;r...">Geode</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00311.html" title="A Geode is a &quot;geometry node&quot;, that is, a leaf node on the scene graph that can have &quot;r...">Geode</a>, otherwise return 0. </p>
<p>Equivalent to dynamic_cast&lt;const Geode*&gt;(this). </p>

<p>Reimplemented in <a class="el" href="a00311.html#ad45c3994ac4568c722040591254d0d09">osg::Geode</a>.</p>

</div>
</div>
<a class="anchor" id="a5685f61aec39a1df350b2e707cea05cc"></a><!-- doxytag: member="osg::Node::asGroup" ref="a5685f61aec39a1df350b2e707cea05cc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00338.html">Group</a>* osg::Node::asGroup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convert 'this' into a <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>, otherwise return 0. </p>
<p>Equivalent to dynamic_cast&lt;Group*&gt;(this). </p>

<p>Reimplemented in <a class="el" href="a00338.html#a4528ad56c755b53021fcddf8a7c5c2bf">osg::Group</a>.</p>

</div>
</div>
<a class="anchor" id="aad6973a39010d3c44e91301204680df5"></a><!-- doxytag: member="osg::Node::asGroup" ref="aad6973a39010d3c44e91301204680df5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="a00338.html">Group</a>* osg::Node::asGroup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convert 'const this' into a const <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00338.html" title="General group node which maintains a list of children.">Group</a>, otherwise return 0. </p>
<p>Equivalent to dynamic_cast&lt;const Group*&gt;(this). </p>

<p>Reimplemented in <a class="el" href="a00338.html#ac51a58f84828cef43160d5f620220906">osg::Group</a>.</p>

</div>
</div>
<a class="anchor" id="af2deff597acc55362d0c4d102715f731"></a><!-- doxytag: member="osg::Node::asSwitch" ref="af2deff597acc55362d0c4d102715f731" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00852.html">Switch</a>* osg::Node::asSwitch </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert 'this' into a <a class="el" href="a00852.html" title="Switch is a Group node that allows switching between children.">Switch</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00852.html" title="Switch is a Group node that allows switching between children.">Switch</a>, otherwise return 0. </p>
<p>Equivalent to dynamic_cast&lt;Switch*&gt;(this). </p>

<p>Reimplemented in <a class="el" href="a00852.html#a8993407d082883b91c83400185cb3d5b">osg::Switch</a>.</p>

</div>
</div>
<a class="anchor" id="ac07b3226938539c7853ea5eab390dc7a"></a><!-- doxytag: member="osg::Node::asSwitch" ref="ac07b3226938539c7853ea5eab390dc7a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="a00852.html">Switch</a>* osg::Node::asSwitch </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convert 'const this' into a const <a class="el" href="a00852.html" title="Switch is a Group node that allows switching between children.">Switch</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00852.html" title="Switch is a Group node that allows switching between children.">Switch</a>, otherwise return 0. </p>
<p>Equivalent to dynamic_cast&lt;const Switch*&gt;(this). </p>

<p>Reimplemented in <a class="el" href="a00852.html#a8943a18b02a60254ac686bbb083d77d2">osg::Switch</a>.</p>

</div>
</div>
<a class="anchor" id="a9ae26553ceb82e99417a8c73c00fe3b0"></a><!-- doxytag: member="osg::Node::asTransform" ref="a9ae26553ceb82e99417a8c73c00fe3b0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="a00928.html">Transform</a>* osg::Node::asTransform </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convert 'const this' into a const <a class="el" href="a00928.html" title="A Transform is a group node for which all children are transformed by a 4x4 matrix.">Transform</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00928.html" title="A Transform is a group node for which all children are transformed by a 4x4 matrix.">Transform</a>, otherwise return 0. </p>
<p>Equivalent to dynamic_cast&lt;const Transform*&gt;(this). </p>

<p>Reimplemented in <a class="el" href="a00928.html#a1ce3c7092f394720703a6496a014a147">osg::Transform</a>.</p>

</div>
</div>
<a class="anchor" id="afc1876e851817deae067a33ea90773c3"></a><!-- doxytag: member="osg::Node::asTransform" ref="afc1876e851817deae067a33ea90773c3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00928.html">Transform</a>* osg::Node::asTransform </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert 'this' into a <a class="el" href="a00928.html" title="A Transform is a group node for which all children are transformed by a 4x4 matrix.">Transform</a> pointer if <a class="el" href="a00491.html" title="Base class for all internal nodes in the scene graph.">Node</a> is a <a class="el" href="a00928.html" title="A Transform is a group node for which all children are transformed by a 4x4 matrix.">Transform</a>, otherwise return 0. </p>
<p>Equivalent to dynamic_cast&lt;Transform*&gt;(this). </p>

<p>Reimplemented in <a class="el" href="a00928.html#a02af493cc3c65588471a21016c613ddd">osg::Transform</a>.</p>

</div>
</div>
<a class="anchor" id="accf4145d104408ed2337166df77aa404"></a><!-- doxytag: member="osg::Node::className" ref="accf4145d104408ed2337166df77aa404" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* osg::Node::className </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the name of the node's class type. </p>

<p>Implements <a class="el" href="a00501.html#a0a2c199f26fdd9ca9fc60d6c79827187">osg::Object</a>.</p>

<p>Reimplemented in <a class="el" href="a00045.html#a2b9bacb915fd41463bba66a02f064192">osg::AutoTransform</a>, <a class="el" href="a00240.html#a53879e548b131307ab557eb9c24ad4f2">osgFX::Effect</a>, <a class="el" href="a00247.html#ace2cb1ac978fe886d7b69fc0ae63885c">osgParticle::Emitter</a>, <a class="el" href="a00541.html#ae2188800c8e499dfd9252c54c80a433a">osgParticle::ParticleEffect</a>, <a class="el" href="a00542.html#aba240adc2b4991994beea019b123e01b">osgParticle::ParticleProcessor</a>, <a class="el" href="a00576.html#a1f948cf30df7552f8a859b6e64a5cacb">osgParticle::PrecipitationEffect</a>, and <a class="el" href="a00581.html#a6166722c93756d51935491db36736ba0">osgParticle::Program</a>.</p>

</div>
</div>
<a class="anchor" id="a110e4fb1ad04efda54b31c03f69a9752"></a><!-- doxytag: member="osg::Node::clone" ref="a110e4fb1ad04efda54b31c03f69a9752" args="(const CopyOp &amp;copyop) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00501.html">Object</a>* osg::Node::clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00169.html">CopyOp</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyop</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return a clone of a node, with Object* return type. </p>

<p>Implements <a class="el" href="a00501.html#ac20abff68448b9fcd20ab59e5d7a0030">osg::Object</a>.</p>

<p>Reimplemented in <a class="el" href="a00045.html#a8fe9855424bc82ffec79f8c937fda904">osg::AutoTransform</a>, and <a class="el" href="a00027.html#a0b931d69cd5b9544f4a3d109e65c9013">osgManipulator::AntiSquish</a>.</p>

</div>
</div>
<a class="anchor" id="a4b52ccde0045dadeea60c49d6963eb7a"></a><!-- doxytag: member="osg::Node::cloneType" ref="a4b52ccde0045dadeea60c49d6963eb7a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00501.html">Object</a>* osg::Node::cloneType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>clone an object of the same type as the node. </p>

<p>Implements <a class="el" href="a00501.html#a837c584d77ae710bb5565f7895f80dbb">osg::Object</a>.</p>

<p>Reimplemented in <a class="el" href="a00045.html#a05ed64bf32036c4b2049401b96cc5c00">osg::AutoTransform</a>, and <a class="el" href="a00027.html#ae48c142d1d9f33c78f47f7c55eb726c5">osgManipulator::AntiSquish</a>.</p>

</div>
</div>
<a class="anchor" id="ac3098a0de0b680b7bf1ebd3547f09cce"></a><!-- doxytag: member="osg::Node::computeBound" ref="ac3098a0de0b680b7bf1ebd3547f09cce" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00070.html">BoundingSphere</a> osg::Node::computeBound </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the bounding sphere around Node's geometry or children. </p>
<p>This method is automatically called by <a class="el" href="a00491.html#a1467f2ad703474ad37a236f87dee1f3a" title="Get the bounding sphere of node.">getBound()</a> when the bounding sphere has been marked dirty via <a class="el" href="a00491.html#ae0c87d5abfa0b64bca79600b77e0f7ba" title="Mark this node&#39;s bounding sphere dirty.">dirtyBound()</a>. </p>

<p>Reimplemented in <a class="el" href="a00045.html#a03e9003afc4991c6e532b91b184c4356">osg::AutoTransform</a>, <a class="el" href="a00056.html#a6fd76a367acfa8c5fd659854a9864702">osg::Billboard</a>, <a class="el" href="a00105.html#ad9cbfc5ee174a1ba80df8038fcc09cca">osg::ClipNode</a>, <a class="el" href="a00311.html#aa0116733a32fc3633895027accadfa71">osg::Geode</a>, <a class="el" href="a00338.html#ab95d0f7f693111e5b5ec57ce786d2d1a">osg::Group</a>, <a class="el" href="a00434.html#aa8238ec89af5f40a804057d680189254">osg::LightSource</a>, <a class="el" href="a00451.html#acd6a505622a771a686b38d85b0ce2043">osg::LOD</a>, <a class="el" href="a00510.html#aae44ecbb46d94102c4231a1a2bb2254b">osg::OccluderNode</a>, <a class="el" href="a00511.html#a779fa965174a74ca586f98308d898f77">osg::OcclusionQueryNode</a>, <a class="el" href="a00603.html#a89a34dd2cd5b58ab4d04328fc3ba123b">osg::ProxyNode</a>, <a class="el" href="a00852.html#a31c731c6f4e3ca4aa785080c39b0eca5">osg::Switch</a>, <a class="el" href="a00928.html#a87d6acb280aee16afcd6a953450610e5">osg::Transform</a>, <a class="el" href="a00542.html#a7be719441c90e6102314708379a180bb">osgParticle::ParticleProcessor</a>, <a class="el" href="a00544.html#a96f6bed53f48f3b28529244bc956f201">osgParticle::ParticleSystemUpdater</a>, <a class="el" href="a00363.html#add2312d3d0601c45f8a40665ad219035">osgSim::Impostor</a>, <a class="el" href="a00432.html#a1ced0cd79a7158ed2db8054ddd9d6468">osgSim::LightPointNode</a>, <a class="el" href="a00884.html#aa26d396c95139afaa44d6e2703e96257">osgTerrain::TerrainTile</a>, and <a class="el" href="a01107.html#ad6044f8a96c98d5e067ff0cfef58cae9">osgVolume::VolumeTile</a>.</p>

</div>
</div>
<a class="anchor" id="a4f3cb1001ed1187e15e40ae1b9e17139"></a><!-- doxytag: member="osg::Node::containsOccluderNodes" ref="a4f3cb1001ed1187e15e40ae1b9e17139" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osg::Node::containsOccluderNodes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return true if this node is an <a class="el" href="a00510.html" title="OccluderNode is a Group node which allows OccluderNodeing between children.">OccluderNode</a> or the subgraph below this node are OccluderNodes. </p>

</div>
</div>
<a class="anchor" id="ae0c87d5abfa0b64bca79600b77e0f7ba"></a><!-- doxytag: member="osg::Node::dirtyBound" ref="ae0c87d5abfa0b64bca79600b77e0f7ba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::dirtyBound </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mark this node's bounding sphere dirty. </p>
<p>Forcing it to be computed on the next call to <a class="el" href="a00491.html#a1467f2ad703474ad37a236f87dee1f3a" title="Get the bounding sphere of node.">getBound()</a>. </p>

</div>
</div>
<a class="anchor" id="a1467f2ad703474ad37a236f87dee1f3a"></a><!-- doxytag: member="osg::Node::getBound" ref="a1467f2ad703474ad37a236f87dee1f3a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00070.html">BoundingSphere</a>&amp; osg::Node::getBound </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the bounding sphere of node. </p>
<p>Using lazy evaluation computes the bounding sphere if it is 'dirty'. </p>

<p>Referenced by <a class="el" href="a00181.html#acd0d65497baa830079d1805301fe3ef7">osg::CullStack::isCulled()</a>.</p>

</div>
</div>
<a class="anchor" id="a81c706c09c92ac530be833d70077c614"></a><!-- doxytag: member="osg::Node::getComputeBoundingSphereCallback" ref="a81c706c09c92ac530be833d70077c614" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00133.html">ComputeBoundingSphereCallback</a>* osg::Node::getComputeBoundingSphereCallback </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the compute bound callback. </p>

</div>
</div>
<a class="anchor" id="a786682fb9b3496252525abba4a674a57"></a><!-- doxytag: member="osg::Node::getComputeBoundingSphereCallback" ref="a786682fb9b3496252525abba4a674a57" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00133.html">ComputeBoundingSphereCallback</a>* osg::Node::getComputeBoundingSphereCallback </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the const compute bound callback. </p>

</div>
</div>
<a class="anchor" id="a8be56b8cd46661f9dd5bbe151edf7299"></a><!-- doxytag: member="osg::Node::getCullCallback" ref="a8be56b8cd46661f9dd5bbe151edf7299" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00493.html">NodeCallback</a>* osg::Node::getCullCallback </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get cull node callback, called during cull traversal. </p>

<p>Referenced by <a class="el" href="a00182.html#ad10b06fd35ed7a074addc812037948d7">osgUtil::CullVisitor::handle_cull_callbacks_and_accept()</a>, <a class="el" href="a00182.html#a579a2daab221b691ed6edbc5b3b188cd">osgUtil::CullVisitor::handle_cull_callbacks_and_traverse()</a>, and <a class="el" href="a00519.html#ad8536a5e2cec2fbfc8b8f30ec332aa68">osgUtil::Optimizer::isOperationPermissibleForObjectImplementation()</a>.</p>

</div>
</div>
<a class="anchor" id="a7316d559c4f5eb9cebda5a65c6e3433a"></a><!-- doxytag: member="osg::Node::getCullCallback" ref="a7316d559c4f5eb9cebda5a65c6e3433a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00493.html">NodeCallback</a>* osg::Node::getCullCallback </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get const cull node callback, called during cull traversal. </p>

</div>
</div>
<a class="anchor" id="afbb5bbdc81694fb89b96c292bd30e810"></a><!-- doxytag: member="osg::Node::getCullingActive" ref="afbb5bbdc81694fb89b96c292bd30e810" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osg::Node::getCullingActive </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the view frustum/small feature _cullingActive flag for this node. </p>
<p>Used as a guide to the cull traversal. </p>

</div>
</div>
<a class="anchor" id="a6487f1d4879871c6e8422380491151f5"></a><!-- doxytag: member="osg::Node::getDescription" ref="a6487f1d4879871c6e8422380491151f5" args="(unsigned int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; osg::Node::getDescription </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a single const description of the const node. </p>

</div>
</div>
<a class="anchor" id="aad08ff52e592b8620fa5346bcdf4d16b"></a><!-- doxytag: member="osg::Node::getDescription" ref="aad08ff52e592b8620fa5346bcdf4d16b" args="(unsigned int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; osg::Node::getDescription </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a single description of the node. </p>

</div>
</div>
<a class="anchor" id="a37b2c00d68c75b583e2d7e5efaa40db4"></a><!-- doxytag: member="osg::Node::getDescriptions" ref="a37b2c00d68c75b583e2d7e5efaa40db4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00491.html#a7f7cfbdff46aa5041d5cd1fb20dc43a2">DescriptionList</a>&amp; osg::Node::getDescriptions </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the description list of the node. </p>

</div>
</div>
<a class="anchor" id="a7fca2d83852afa6027abd7cec6ff2ef5"></a><!-- doxytag: member="osg::Node::getDescriptions" ref="a7fca2d83852afa6027abd7cec6ff2ef5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00491.html#a7f7cfbdff46aa5041d5cd1fb20dc43a2">DescriptionList</a>&amp; osg::Node::getDescriptions </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the const description list of the const node. </p>

</div>
</div>
<a class="anchor" id="a08fd9ffa53bd8f0bcaf6b7c292bd1312"></a><!-- doxytag: member="osg::Node::getEventCallback" ref="a08fd9ffa53bd8f0bcaf6b7c292bd1312" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00493.html">NodeCallback</a>* osg::Node::getEventCallback </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get const event node callback, called during event traversal. </p>

</div>
</div>
<a class="anchor" id="aca44e8707d023fcbc6af05ea3e17c872"></a><!-- doxytag: member="osg::Node::getEventCallback" ref="aca44e8707d023fcbc6af05ea3e17c872" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00493.html">NodeCallback</a>* osg::Node::getEventCallback </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get event node callback, called during event traversal. </p>

<p>Referenced by <a class="el" href="a00258.html#ae4c001c7361ae61034a6c29ddeabde15">osgGA::EventVisitor::handle_callbacks_and_traverse()</a>, <a class="el" href="a00258.html#a409412dde78de23e1fe37aa7d47640ff">osgGA::EventVisitor::handle_geode_callbacks()</a>, <a class="el" href="a00519.html#ad8536a5e2cec2fbfc8b8f30ec332aa68">osgUtil::Optimizer::isOperationPermissibleForObjectImplementation()</a>, and <a class="el" href="a00258.html#a9cc6d9c72f9280259d569e57b174c740">osgGA::EventVisitor::traverseGeode()</a>.</p>

</div>
</div>
<a class="anchor" id="a36660a84e8ecb270deecc36c9b4ab3ca"></a><!-- doxytag: member="osg::Node::getInitialBound" ref="a36660a84e8ecb270deecc36c9b4ab3ca" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00070.html">BoundingSphere</a>&amp; osg::Node::getInitialBound </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the initial bounding volume to use when computing the overall bounding volume. </p>

</div>
</div>
<a class="anchor" id="a38566f0dc432e18aa77ad8fc70e48da2"></a><!-- doxytag: member="osg::Node::getNodeMask" ref="a38566f0dc432e18aa77ad8fc70e48da2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00491.html#ab973b9ec7cebae692032e1038d951e23">NodeMask</a> osg::Node::getNodeMask </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the node Mask. </p>

<p>Referenced by <a class="el" href="a00519.html#ad8536a5e2cec2fbfc8b8f30ec332aa68">osgUtil::Optimizer::isOperationPermissibleForObjectImplementation()</a>, and <a class="el" href="a00497.html#a598080f7dc764386844a68bfa4e8e12b">osg::NodeVisitor::validNodeMask()</a>.</p>

</div>
</div>
<a class="anchor" id="aa1ca13749e35228ff6f7fbbf8f9b1f99"></a><!-- doxytag: member="osg::Node::getNumChildrenRequiringEventTraversal" ref="aa1ca13749e35228ff6f7fbbf8f9b1f99" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int osg::Node::getNumChildrenRequiringEventTraversal </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of Children of this node which require Event traversal, since they have an Event Callback attached to them or their children. </p>

</div>
</div>
<a class="anchor" id="a3135de114532ef9a62c59b507411bd59"></a><!-- doxytag: member="osg::Node::getNumChildrenRequiringUpdateTraversal" ref="a3135de114532ef9a62c59b507411bd59" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int osg::Node::getNumChildrenRequiringUpdateTraversal </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of Children of this node which require Update traversal, since they have an Update Callback attached to them or their children. </p>

</div>
</div>
<a class="anchor" id="a998231a2ce906d5ee53bd0629e857365"></a><!-- doxytag: member="osg::Node::getNumChildrenWithCullingDisabled" ref="a998231a2ce906d5ee53bd0629e857365" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int osg::Node::getNumChildrenWithCullingDisabled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of Children of this node which have culling disabled. </p>

</div>
</div>
<a class="anchor" id="a70012fc9e8c642bff54f6b87a1eff4e1"></a><!-- doxytag: member="osg::Node::getNumChildrenWithOccluderNodes" ref="a70012fc9e8c642bff54f6b87a1eff4e1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int osg::Node::getNumChildrenWithOccluderNodes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of Children of this node which are or have OccluderNode's. </p>

<p>Referenced by <a class="el" href="a00108.html#ad61b4540ebe43a56701646f3bcaaed7f">osg::CollectOccludersVisitor::handle_cull_callbacks_and_accept()</a>, and <a class="el" href="a00108.html#a13b40d0e40340d27e1c149386261dec8">osg::CollectOccludersVisitor::handle_cull_callbacks_and_traverse()</a>.</p>

</div>
</div>
<a class="anchor" id="af46335dfd98ea6a89192ab4ffebb3761"></a><!-- doxytag: member="osg::Node::getNumDescriptions" ref="af46335dfd98ea6a89192ab4ffebb3761" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int osg::Node::getNumDescriptions </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of descriptions of the node. </p>

<p>Referenced by <a class="el" href="a00519.html#ad8536a5e2cec2fbfc8b8f30ec332aa68">osgUtil::Optimizer::isOperationPermissibleForObjectImplementation()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e301ad455a59ead4b9111a21a97bf6f"></a><!-- doxytag: member="osg::Node::getNumParents" ref="a7e301ad455a59ead4b9111a21a97bf6f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int osg::Node::getNumParents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of parents of node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of parents of this node. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d1a3831e239372dc743321226856e39"></a><!-- doxytag: member="osg::Node::getOrCreateStateSet" ref="a1d1a3831e239372dc743321226856e39" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00749.html">osg::StateSet</a>* osg::Node::getOrCreateStateSet </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the node's <a class="el" href="a00749.html" title="Stores a set of modes and attributes which represent a set of OpenGL state.">StateSet</a>, if one does not already exist create it set the node and return the newly created <a class="el" href="a00749.html" title="Stores a set of modes and attributes which represent a set of OpenGL state.">StateSet</a>. </p>
<p>This ensures that a valid <a class="el" href="a00749.html" title="Stores a set of modes and attributes which represent a set of OpenGL state.">StateSet</a> is always returned and can be used directly. </p>

</div>
</div>
<a class="anchor" id="afa64f11832262a6ddb3824b9afbdddc9"></a><!-- doxytag: member="osg::Node::getParent" ref="afa64f11832262a6ddb3824b9afbdddc9" args="(unsigned int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00338.html">Group</a>* osg::Node::getParent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adafb5475dc066724a18eaea8bba7b27f"></a><!-- doxytag: member="osg::Node::getParent" ref="adafb5475dc066724a18eaea8bba7b27f" args="(unsigned int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00338.html">Group</a>* osg::Node::getParent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a single const parent of node. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>index of the parent to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the parent i. </dd></dl>

</div>
</div>
<a class="anchor" id="a189e62483ac0359c811917ea01f24ac4"></a><!-- doxytag: member="osg::Node::getParentalNodePaths" ref="a189e62483ac0359c811917ea01f24ac4" args="(osg::Node *haltTraversalAtNode=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01635.html#a65ddcb6ba8f49d0b40812a3cf4122246">NodePathList</a> osg::Node::getParentalNodePaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00491.html">osg::Node</a> *&nbsp;</td>
          <td class="paramname"> <em>haltTraversalAtNode</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the list of node paths parent paths. </p>
<p>The optional Node* haltTraversalAtNode allows the user to prevent traversal beyond a specifed node. </p>

</div>
</div>
<a class="anchor" id="ab004bf059235681112a5d4048f83b902"></a><!-- doxytag: member="osg::Node::getParents" ref="ab004bf059235681112a5d4048f83b902" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00491.html#a43a8294c266bdedcb63d0d3db59ac882">ParentList</a> osg::Node::getParents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the a copy of parent list of node. </p>
<p>A copy is returned to prevent modification of the parent list. </p>

</div>
</div>
<a class="anchor" id="a8325cc82518522125eca8d35924806ec"></a><!-- doxytag: member="osg::Node::getParents" ref="a8325cc82518522125eca8d35924806ec" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00491.html#a43a8294c266bdedcb63d0d3db59ac882">ParentList</a>&amp; osg::Node::getParents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the parent list of node. </p>

</div>
</div>
<a class="anchor" id="acbb0db6111bccbf9327a4d15a5cf6936"></a><!-- doxytag: member="osg::Node::getStateSet" ref="acbb0db6111bccbf9327a4d15a5cf6936" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00749.html">osg::StateSet</a>* osg::Node::getStateSet </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the node's const <a class="el" href="a00749.html" title="Stores a set of modes and attributes which represent a set of OpenGL state.">StateSet</a>. </p>
<p>Returns NULL if a stateset is not attached. </p>

</div>
</div>
<a class="anchor" id="a476fe31b2d9b0f591bd1e8377ab4b586"></a><!-- doxytag: member="osg::Node::getStateSet" ref="a476fe31b2d9b0f591bd1e8377ab4b586" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00749.html">osg::StateSet</a>* osg::Node::getStateSet </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the node's <a class="el" href="a00749.html" title="Stores a set of modes and attributes which represent a set of OpenGL state.">StateSet</a>. </p>
<p>returns NULL if a stateset is not attached. </p>

<p>Referenced by <a class="el" href="a01055.html#aff0633e01a448dff36bd700ce7b24f51">osgUtil::UpdateVisitor::handle_callbacks_and_traverse()</a>, <a class="el" href="a00258.html#ae4c001c7361ae61034a6c29ddeabde15">osgGA::EventVisitor::handle_callbacks_and_traverse()</a>, <a class="el" href="a01055.html#a522f631dc1feab7ba035b25535cfa3e8">osgUtil::UpdateVisitor::handle_geode_callbacks()</a>, <a class="el" href="a00258.html#a409412dde78de23e1fe37aa7d47640ff">osgGA::EventVisitor::handle_geode_callbacks()</a>, <a class="el" href="a00519.html#ad8536a5e2cec2fbfc8b8f30ec332aa68">osgUtil::Optimizer::isOperationPermissibleForObjectImplementation()</a>, and <a class="el" href="a00258.html#a9cc6d9c72f9280259d569e57b174c740">osgGA::EventVisitor::traverseGeode()</a>.</p>

</div>
</div>
<a class="anchor" id="ac51f7b1f5636cc1d671d2ae87855c7bc"></a><!-- doxytag: member="osg::Node::getUpdateCallback" ref="ac51f7b1f5636cc1d671d2ae87855c7bc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00493.html">NodeCallback</a>* osg::Node::getUpdateCallback </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get update node callback, called during update traversal. </p>

<p>Referenced by <a class="el" href="a01055.html#aff0633e01a448dff36bd700ce7b24f51">osgUtil::UpdateVisitor::handle_callbacks_and_traverse()</a>, <a class="el" href="a01055.html#a522f631dc1feab7ba035b25535cfa3e8">osgUtil::UpdateVisitor::handle_geode_callbacks()</a>, and <a class="el" href="a00519.html#ad8536a5e2cec2fbfc8b8f30ec332aa68">osgUtil::Optimizer::isOperationPermissibleForObjectImplementation()</a>.</p>

</div>
</div>
<a class="anchor" id="a36ee6471fa5d47a3cf02c0f95a8219dd"></a><!-- doxytag: member="osg::Node::getUpdateCallback" ref="a36ee6471fa5d47a3cf02c0f95a8219dd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00493.html">NodeCallback</a>* osg::Node::getUpdateCallback </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get const update node callback, called during update traversal. </p>

</div>
</div>
<a class="anchor" id="a4db296a84c57af8b2297c175007df4c7"></a><!-- doxytag: member="osg::Node::getWorldMatrices" ref="a4db296a84c57af8b2297c175007df4c7" args="(const osg::Node *haltTraversalAtNode=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01635.html#a22d1eac701d86ccc45b1e9c1e676d3e2">MatrixList</a> osg::Node::getWorldMatrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00491.html">osg::Node</a> *&nbsp;</td>
          <td class="paramname"> <em>haltTraversalAtNode</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the list of matrices that transform this node from local coordinates to world coordinates. </p>
<p>The optional Node* haltTraversalAtNode allows the user to prevent traversal beyond a specifed node. </p>

</div>
</div>
<a class="anchor" id="add3db83625ea19747332ef780685eb72"></a><!-- doxytag: member="osg::Node::isCullingActive" ref="add3db83625ea19747332ef780685eb72" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osg::Node::isCullingActive </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if this node can be culled by view frustum, occlusion or small feature culling during the cull traversal. </p>
<p>Note, returns true only if no children have culling disabled, and the local _cullingActive flag is true. </p>

<p>Referenced by <a class="el" href="a00181.html#acd0d65497baa830079d1805301fe3ef7">osg::CullStack::isCulled()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e31528058dae0a90b113adee3653ecc"></a><!-- doxytag: member="osg::Node::isSameKindAs" ref="a3e31528058dae0a90b113adee3653ecc" args="(const Object *obj) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool osg::Node::isSameKindAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00501.html">Object</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return true if this and obj are of the same kind of object. </p>

<p>Reimplemented from <a class="el" href="a00501.html#ac3b05ac28940dda755014a821b699f3a">osg::Object</a>.</p>

<p>Reimplemented in <a class="el" href="a00045.html#a0198baf6ae3124ad817373d00e5e3479">osg::AutoTransform</a>, <a class="el" href="a00240.html#ae7e9d697a0799d3f9444e487f7037f2e">osgFX::Effect</a>, <a class="el" href="a00027.html#a6f37ee5625f80284cdc9a7ac72c80093">osgManipulator::AntiSquish</a>, <a class="el" href="a00247.html#af020b8d12532cfeb93d55a6d9ed8965d">osgParticle::Emitter</a>, <a class="el" href="a00541.html#ad9cb166ec5f8e21caf89cc40151cfa39">osgParticle::ParticleEffect</a>, <a class="el" href="a00542.html#aaf21b61fcb8422c2c304fcf33a0d1241">osgParticle::ParticleProcessor</a>, <a class="el" href="a00576.html#aa6cb90994886768e993688c6f8b6d267">osgParticle::PrecipitationEffect</a>, and <a class="el" href="a00581.html#a11be04b8c80717b0c0442c054cac5053">osgParticle::Program</a>.</p>

<p>References <a class="el" href="a01163.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="a40919ed617cdf7238ad99e5d2f0a330f"></a><!-- doxytag: member="osg::Node::libraryName" ref="a40919ed617cdf7238ad99e5d2f0a330f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* osg::Node::libraryName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the name of the node's library. </p>

<p>Implements <a class="el" href="a00501.html#adac3709b960df44030d682dd1336413e">osg::Object</a>.</p>

<p>Reimplemented in <a class="el" href="a00045.html#a61d9eef6b25e94100617332c4292f008">osg::AutoTransform</a>, <a class="el" href="a00240.html#a03988033b6926c39e7ffa24b55f3016e">osgFX::Effect</a>, <a class="el" href="a00247.html#ad57ef7b30b28c88546598a6a164a5e55">osgParticle::Emitter</a>, <a class="el" href="a00541.html#a57fca1f5229c296984fa31d3f4844f2e">osgParticle::ParticleEffect</a>, <a class="el" href="a00542.html#ab4276f3804b7fc63475bca11f7004dd2">osgParticle::ParticleProcessor</a>, <a class="el" href="a00576.html#a4d59cc803400f2ed97cac4ea219b3f25">osgParticle::PrecipitationEffect</a>, and <a class="el" href="a00581.html#acf85e8a677603d417bc23c95585758de">osgParticle::Program</a>.</p>

</div>
</div>
<a class="anchor" id="ad42811ad450626b5921aad11543cbf4c"></a><!-- doxytag: member="osg::Node::releaseGLObjects" ref="ad42811ad450626b5921aad11543cbf4c" args="(osg::State *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void osg::Node::releaseGLObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00745.html">osg::State</a> *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If <a class="el" href="a00745.html" title="Encapsulates the current applied OpenGL modes, attributes and vertex arrays settings, implements lazy state updating and provides accessors for querying the current state.">State</a> is non-zero, this function releases any associated OpenGL objects for the specified graphics context. </p>
<p>Otherwise, releases OpenGL objects for all graphics contexts. </p>

<p>Reimplemented from <a class="el" href="a00501.html#a9a372b2d2ccedae228f526d8409cda66">osg::Object</a>.</p>

<p>Reimplemented in <a class="el" href="a00311.html#a3ec684d1c6fba38022eda9da4d1b1978">osg::Geode</a>, <a class="el" href="a00338.html#add2ef7fed87eb083a46776e122b9991f">osg::Group</a>, <a class="el" href="a00511.html#ae17d458a44555c1fafa4da3aae1df03e">osg::OcclusionQueryNode</a>, and <a class="el" href="a00533.html#a309d193faf7bc801e667051442bb7163">osgSim::OverlayNode</a>.</p>

</div>
</div>
<a class="anchor" id="ac7fecd76b2f869d7ae427c03380a4058"></a><!-- doxytag: member="osg::Node::removeCullCallback" ref="ac7fecd76b2f869d7ae427c03380a4058" args="(NodeCallback *nc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::removeCullCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>nc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method that removes a given callback from a node, even if that callback is nested. </p>
<p>There is no error return in case the given callback is not found. </p>

<p>References <a class="el" href="a00493.html#ac9fb1a415c71c554323e52e8c7469947">osg::NodeCallback::getNestedCallback()</a>, and <a class="el" href="a01163.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="a003e329a107abd6b660a1a58d86f7846"></a><!-- doxytag: member="osg::Node::removeEventCallback" ref="a003e329a107abd6b660a1a58d86f7846" args="(NodeCallback *nc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::removeEventCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>nc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method that removes a given callback from a node, even if that callback is nested. </p>
<p>There is no error return in case the given callback is not found. </p>

<p>References <a class="el" href="a00493.html#ac9fb1a415c71c554323e52e8c7469947">osg::NodeCallback::getNestedCallback()</a>, and <a class="el" href="a01163.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="a3185b5fb0ece1025a4d3d7a6bca788eb"></a><!-- doxytag: member="osg::Node::removeParent" ref="a3185b5fb0ece1025a4d3d7a6bca788eb" args="(osg::Group *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::removeParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00338.html">osg::Group</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2cfeff242a6edef283ce39eb698751e7"></a><!-- doxytag: member="osg::Node::removeUpdateCallback" ref="a2cfeff242a6edef283ce39eb698751e7" args="(NodeCallback *nc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::removeUpdateCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>nc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method that removes a given callback from a node, even if that callback is nested. </p>
<p>There is no error return in case the given callback is not found. </p>

<p>References <a class="el" href="a00493.html#ac9fb1a415c71c554323e52e8c7469947">osg::NodeCallback::getNestedCallback()</a>, and <a class="el" href="a01163.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="a573872f56780b6f8081673969cec664a"></a><!-- doxytag: member="osg::Node::resizeGLObjectBuffers" ref="a573872f56780b6f8081673969cec664a" args="(unsigned int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void osg::Node::resizeGLObjectBuffers </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>int</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize any per context GLObject buffers to specified size. </p>

<p>Reimplemented from <a class="el" href="a00501.html#aad5292689187427551b90ae7ef40b9a8">osg::Object</a>.</p>

<p>Reimplemented in <a class="el" href="a00311.html#ae6fed0dd0c0a6206fbf8ac3857c94933">osg::Geode</a>, <a class="el" href="a00338.html#a4049ebe617e25b77f24001c86ca16f07">osg::Group</a>, and <a class="el" href="a00533.html#ad72c519463e68ec87d9369f5705a18ba">osgSim::OverlayNode</a>.</p>

</div>
</div>
<a class="anchor" id="a7be58d053003c303c036d9490e1e7348"></a><!-- doxytag: member="osg::Node::setComputeBoundingSphereCallback" ref="a7be58d053003c303c036d9490e1e7348" args="(ComputeBoundingSphereCallback *callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::setComputeBoundingSphereCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00133.html">ComputeBoundingSphereCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the compute bound callback to override the default computeBound. </p>

</div>
</div>
<a class="anchor" id="a8fcdb41e2019787b597a9e3f651696ae"></a><!-- doxytag: member="osg::Node::setCullCallback" ref="a8fcdb41e2019787b597a9e3f651696ae" args="(NodeCallback *nc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::setCullCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>nc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set cull node callback, called during cull traversal. </p>

</div>
</div>
<a class="anchor" id="a7a5b00fb04dd0352a3ba76f7bf0a9e00"></a><!-- doxytag: member="osg::Node::setCullingActive" ref="a7a5b00fb04dd0352a3ba76f7bf0a9e00" args="(bool active)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::setCullingActive </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>active</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the view frustum/small feature culling of this node to be active or inactive. </p>
<p>The default value is true for _cullingActive. Used as a guide to the cull traversal. </p>

</div>
</div>
<a class="anchor" id="aae20f94cd51d44bd463e7280e52b4edc"></a><!-- doxytag: member="osg::Node::setDescriptions" ref="aae20f94cd51d44bd463e7280e52b4edc" args="(const DescriptionList &amp;descriptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::setDescriptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00491.html#a7f7cfbdff46aa5041d5cd1fb20dc43a2">DescriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>descriptions</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the description list of the node. </p>

</div>
</div>
<a class="anchor" id="aa1c317a8bdb9759f6fd85e4a256d72b7"></a><!-- doxytag: member="osg::Node::setEventCallback" ref="aa1c317a8bdb9759f6fd85e4a256d72b7" args="(NodeCallback *nc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::setEventCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>nc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set event node callback, called during event traversal. </p>

</div>
</div>
<a class="anchor" id="a743b4b12bde43d75eae673db804fb09d"></a><!-- doxytag: member="osg::Node::setInitialBound" ref="a743b4b12bde43d75eae673db804fb09d" args="(const osg::BoundingSphere &amp;bsphere)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::setInitialBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00070.html">osg::BoundingSphere</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bsphere</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the initial bounding volume to use when computing the overall bounding volume. </p>

</div>
</div>
<a class="anchor" id="a93db475215310e88ddd9c717b7ed623e"></a><!-- doxytag: member="osg::Node::setNodeMask" ref="a93db475215310e88ddd9c717b7ed623e" args="(NodeMask nm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::setNodeMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00491.html#ab973b9ec7cebae692032e1038d951e23">NodeMask</a>&nbsp;</td>
          <td class="paramname"> <em>nm</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the node mask. </p>

</div>
</div>
<a class="anchor" id="a433055a290d0d4d94e5e483206303683"></a><!-- doxytag: member="osg::Node::setNumChildrenRequiringEventTraversal" ref="a433055a290d0d4d94e5e483206303683" args="(unsigned int num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::setNumChildrenRequiringEventTraversal </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a25069f7c69723629bd725796345a8b00"></a><!-- doxytag: member="osg::Node::setNumChildrenRequiringUpdateTraversal" ref="a25069f7c69723629bd725796345a8b00" args="(unsigned int num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::setNumChildrenRequiringUpdateTraversal </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4e08b4fe76c2a3e611b775571005ab1"></a><!-- doxytag: member="osg::Node::setNumChildrenWithCullingDisabled" ref="ab4e08b4fe76c2a3e611b775571005ab1" args="(unsigned int num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::setNumChildrenWithCullingDisabled </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a26ee64ad1f6496faa61e6cbf4ce7de75"></a><!-- doxytag: member="osg::Node::setNumChildrenWithOccluderNodes" ref="a26ee64ad1f6496faa61e6cbf4ce7de75" args="(unsigned int num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::setNumChildrenWithOccluderNodes </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad1948eda88d921795dde2ad326e82236"></a><!-- doxytag: member="osg::Node::setStateSet" ref="ad1948eda88d921795dde2ad326e82236" args="(osg::StateSet *stateset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::setStateSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00749.html">osg::StateSet</a> *&nbsp;</td>
          <td class="paramname"> <em>stateset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the node's <a class="el" href="a00749.html" title="Stores a set of modes and attributes which represent a set of OpenGL state.">StateSet</a>. </p>

</div>
</div>
<a class="anchor" id="aaf10384628ac00e159195d0853e03f5e"></a><!-- doxytag: member="osg::Node::setThreadSafeRefUnref" ref="aaf10384628ac00e159195d0853e03f5e" args="(bool threadSafe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void osg::Node::setThreadSafeRefUnref </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>threadSafe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether to use a mutex to ensure <a class="el" href="a00629.html#acafcbbae9e9d8bfcbc811cc6c36d1cf4" title="Increment the reference count by one, indicating that this object has another pointer which is refere...">ref()</a> and <a class="el" href="a00629.html#a0ee3c1293cceac54bfaabe7c541bcb68" title="Decrement the reference count by one, indicating that a pointer to this object is referencing it...">unref()</a> are thread safe. </p>

<p>Reimplemented from <a class="el" href="a00629.html#aafc0e0779a54c6fbd46bdade701d7fa2">osg::Referenced</a>.</p>

<p>Reimplemented in <a class="el" href="a00311.html#a462be7f5ffe05a63af24efdc3e2f46fa">osg::Geode</a>, <a class="el" href="a00338.html#a6b86895eb8b3ab999cd6a46f5aaaae64">osg::Group</a>, <a class="el" href="a00434.html#a9a919a7b5eb8c8d34714903018b1f3e0">osg::LightSource</a>, <a class="el" href="a00894.html#a36e96e657117fced6a98dbe2b50afe05">osg::TexGenNode</a>, and <a class="el" href="a00533.html#afe693b2f38854da138754ccfa9214160">osgSim::OverlayNode</a>.</p>

</div>
</div>
<a class="anchor" id="a7fe444c26b80499bbd19ab3965dd0df3"></a><!-- doxytag: member="osg::Node::setUpdateCallback" ref="a7fe444c26b80499bbd19ab3965dd0df3" args="(NodeCallback *nc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osg::Node::setUpdateCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00493.html">NodeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>nc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set update node callback, called during update traversal. </p>

</div>
</div>
<a class="anchor" id="a16f26e64a5dc77e55b2544388349e668"></a><!-- doxytag: member="osg::Node::traverse" ref="a16f26e64a5dc77e55b2544388349e668" args="(NodeVisitor &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void osg::Node::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00497.html">NodeVisitor</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Traverse downwards : calls children's accept method with <a class="el" href="a00497.html" title="Visitor for type safe operations on osg::Nodes.">NodeVisitor</a>. </p>

<p>Reimplemented in <a class="el" href="a00338.html#a189db7193e544ac67947c982b39aa435">osg::Group</a>, <a class="el" href="a00451.html#af06ce5afa734713fa63d5d089e93570c">osg::LOD</a>, <a class="el" href="a00534.html#aee2db3f36c00be5c1139e87829ac2adc">osg::PagedLOD</a>, <a class="el" href="a00603.html#a142207d27c4ca8b5e6948bb4f96c60e3">osg::ProxyNode</a>, <a class="el" href="a00698.html#a20c6891a6f2710b215989876dd4f60c6">osg::Sequence</a>, <a class="el" href="a00852.html#a699892f8df89915cc0aed1bd312ca304">osg::Switch</a>, <a class="el" href="a00240.html#aceebb7f8d95c8531b4ed1fe27b45a8f3">osgFX::Effect</a>, <a class="el" href="a00542.html#ae985513cee0497632994780fb34c6ec9">osgParticle::ParticleProcessor</a>, <a class="el" href="a00544.html#af9223a6e65ebb3be2c2989bf21647794">osgParticle::ParticleSystemUpdater</a>, <a class="el" href="a00576.html#ab19f7773f5fb144d728baf8919188f4a">osgParticle::PrecipitationEffect</a>, <a class="el" href="a00706.html#a9fa725b3c97333e4456c428fb97698d4">osgShadow::ShadowedScene</a>, <a class="el" href="a00213.html#a06021de2626cc732ad15fb5f32d20f3a">osgSim::DOFTransform</a>, <a class="el" href="a00363.html#a119f402ecb007df41af07885b2dd6862">osgSim::Impostor</a>, <a class="el" href="a00432.html#afe5a9e6c04d7e0b45f6729a7c205db33">osgSim::LightPointNode</a>, <a class="el" href="a00486.html#a5d8aad9fddc424ead69cd847feec41f9">osgSim::MultiSwitch</a>, <a class="el" href="a00533.html#ab252c61ad690cfd2808ddfcd920c4cea">osgSim::OverlayNode</a>, <a class="el" href="a01102.html#ab78fdffc92337f998a34be8f57d9f508">osgSim::VisibilityGroup</a>, <a class="el" href="a00881.html#a7753bd2e094bf50d35d127770f301d08">osgTerrain::Terrain</a>, <a class="el" href="a00884.html#a825c985b48aa7e01f68103c8bc8bec6f">osgTerrain::TerrainTile</a>, <a class="el" href="a01105.html#a6afa16b46ace233a7d82db91b8fa7e6d">osgVolume::Volume</a>, and <a class="el" href="a01107.html#ac94975ae770d9c4876e8d011b0d48752">osgVolume::VolumeTile</a>.</p>

<p>Referenced by <a class="el" href="a00497.html#a95e2e46371a099bc4bd6749c19aab029">osg::NodeVisitor::traverse()</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="af7c3ee69924c55e0590e04f5d11abe93"></a><!-- doxytag: member="osg::Node::osg::Drawable" ref="af7c3ee69924c55e0590e04f5d11abe93" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="a00216.html">osg::Drawable</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8c78c91a5b28f80a42253ce9a2f90d62"></a><!-- doxytag: member="osg::Node::osg::Group" ref="a8c78c91a5b28f80a42253ce9a2f90d62" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="a00338.html">osg::Group</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7593955b51fad9f6836d9ffb2539181d"></a><!-- doxytag: member="osg::Node::osg::StateSet" ref="a7593955b51fad9f6836d9ffb2539181d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="a00749.html">osg::StateSet</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="afaa1be92dabff7b02aa71d8f9fad41f4"></a><!-- doxytag: member="osg::Node::_boundingSphere" ref="afaa1be92dabff7b02aa71d8f9fad41f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html">BoundingSphere</a> <a class="el" href="a00491.html#afaa1be92dabff7b02aa71d8f9fad41f4">osg::Node::_boundingSphere</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af4b630e69630574f2396306530150222"></a><!-- doxytag: member="osg::Node::_boundingSphereComputed" ref="af4b630e69630574f2396306530150222" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00491.html#af4b630e69630574f2396306530150222">osg::Node::_boundingSphereComputed</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1978ffb819195d9e18e354fd315a9394"></a><!-- doxytag: member="osg::Node::_computeBoundCallback" ref="a1978ffb819195d9e18e354fd315a9394" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00626.html">ref_ptr</a>&lt;<a class="el" href="a00133.html">ComputeBoundingSphereCallback</a>&gt; <a class="el" href="a00491.html#a1978ffb819195d9e18e354fd315a9394">osg::Node::_computeBoundCallback</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b6bd1afdbe59668f0342d5ddb49b375"></a><!-- doxytag: member="osg::Node::_cullCallback" ref="a0b6bd1afdbe59668f0342d5ddb49b375" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00626.html">ref_ptr</a>&lt;<a class="el" href="a00493.html">NodeCallback</a>&gt; <a class="el" href="a00491.html#a0b6bd1afdbe59668f0342d5ddb49b375">osg::Node::_cullCallback</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a11da6726a72e15cb4ec3d8ca90baaefb"></a><!-- doxytag: member="osg::Node::_cullingActive" ref="a11da6726a72e15cb4ec3d8ca90baaefb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00491.html#a11da6726a72e15cb4ec3d8ca90baaefb">osg::Node::_cullingActive</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac0ad937258357dec411f22b9a4fbf2dc"></a><!-- doxytag: member="osg::Node::_descriptions" ref="ac0ad937258357dec411f22b9a4fbf2dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00491.html#a7f7cfbdff46aa5041d5cd1fb20dc43a2">DescriptionList</a> <a class="el" href="a00491.html#ac0ad937258357dec411f22b9a4fbf2dc">osg::Node::_descriptions</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a28d484e71e9e7beacf2cdfb4c5cb20ab"></a><!-- doxytag: member="osg::Node::_eventCallback" ref="a28d484e71e9e7beacf2cdfb4c5cb20ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00626.html">ref_ptr</a>&lt;<a class="el" href="a00493.html">NodeCallback</a>&gt; <a class="el" href="a00491.html#a28d484e71e9e7beacf2cdfb4c5cb20ab">osg::Node::_eventCallback</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa9571664b6037022c4aa4cac01c1eab7"></a><!-- doxytag: member="osg::Node::_initialBound" ref="aa9571664b6037022c4aa4cac01c1eab7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html">BoundingSphere</a> <a class="el" href="a00491.html#aa9571664b6037022c4aa4cac01c1eab7">osg::Node::_initialBound</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a25a4a53b16d140631c08ba568b7b48d1"></a><!-- doxytag: member="osg::Node::_nodeMask" ref="a25a4a53b16d140631c08ba568b7b48d1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00491.html#ab973b9ec7cebae692032e1038d951e23">NodeMask</a> <a class="el" href="a00491.html#a25a4a53b16d140631c08ba568b7b48d1">osg::Node::_nodeMask</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afd484189b28d131fae2d1c09218df633"></a><!-- doxytag: member="osg::Node::_numChildrenRequiringEventTraversal" ref="afd484189b28d131fae2d1c09218df633" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="a00491.html#afd484189b28d131fae2d1c09218df633">osg::Node::_numChildrenRequiringEventTraversal</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a33ff52bb29a8e192c0c16718a929e6"></a><!-- doxytag: member="osg::Node::_numChildrenRequiringUpdateTraversal" ref="a9a33ff52bb29a8e192c0c16718a929e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="a00491.html#a9a33ff52bb29a8e192c0c16718a929e6">osg::Node::_numChildrenRequiringUpdateTraversal</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aff0c649800ba69c0ed416ccc483f5b7e"></a><!-- doxytag: member="osg::Node::_numChildrenWithCullingDisabled" ref="aff0c649800ba69c0ed416ccc483f5b7e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="a00491.html#aff0c649800ba69c0ed416ccc483f5b7e">osg::Node::_numChildrenWithCullingDisabled</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a134bdee33f86dad7aadfb737a1782aac"></a><!-- doxytag: member="osg::Node::_numChildrenWithOccluderNodes" ref="a134bdee33f86dad7aadfb737a1782aac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="a00491.html#a134bdee33f86dad7aadfb737a1782aac">osg::Node::_numChildrenWithOccluderNodes</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af7eed72246d7bf9c458d87ae3081ca97"></a><!-- doxytag: member="osg::Node::_parents" ref="af7eed72246d7bf9c458d87ae3081ca97" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00491.html#a43a8294c266bdedcb63d0d3db59ac882">ParentList</a> <a class="el" href="a00491.html#af7eed72246d7bf9c458d87ae3081ca97">osg::Node::_parents</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3e97127339b5704bf27ab1662613868a"></a><!-- doxytag: member="osg::Node::_stateset" ref="a3e97127339b5704bf27ab1662613868a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00626.html">ref_ptr</a>&lt;<a class="el" href="a00749.html">StateSet</a>&gt; <a class="el" href="a00491.html#a3e97127339b5704bf27ab1662613868a">osg::Node::_stateset</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9124934cb60d57b38cd5d52c782c6820"></a><!-- doxytag: member="osg::Node::_updateCallback" ref="a9124934cb60d57b38cd5d52c782c6820" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00626.html">ref_ptr</a>&lt;<a class="el" href="a00493.html">NodeCallback</a>&gt; <a class="el" href="a00491.html#a9124934cb60d57b38cd5d52c782c6820">osg::Node::_updateCallback</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>osg/<a class="el" href="a01218.html">Node</a></li>
</ul>
</div>
<hr>
<table border="0"><tr><td>
  <img src="osg32-32.png" alt="osg logo" />
</td><td>
  <address><small>Generated at Thu Jun 9 2011 16:37:15 for the <a href="http://www.openscenegraph.org/">OpenSceneGraph</a>
by <a href="http://www.doxygen.org">doxygen</a> 1.7.1.</small></address>
<!-- Dimitri van Heesch's e-mail address removed, lest he get messages on the OpenSceneGraph -->
</td></tr></table>
</body>
</html>
