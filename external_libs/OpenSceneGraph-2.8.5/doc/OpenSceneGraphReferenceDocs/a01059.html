<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenSceneGraph: osgIntrospection::Value Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="a01640.html">osgIntrospection</a>      </li>
      <li><a class="el" href="a01059.html">osgIntrospection::Value</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>osgIntrospection::Value Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="osgIntrospection::Value" -->
<p><a href="a03227.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>Instance</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>Instance_base</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>Instance_box</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>Instance_box_base</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>Ptr_instance_box</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#aff2070731e7ac55c677afe4fd9c69157">Value</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#aff2070731e7ac55c677afe4fd9c69157"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#a7f8f9e40565bb64d8dc3fc50d5a58041">Value</a> (void *v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct initialization constructor for void pointers.  <a href="#a7f8f9e40565bb64d8dc3fc50d5a58041"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#abc0f57ecfb581d0d310c8f0b903f1a15">Value</a> (const void *v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct initialization constructor for const void pointers.  <a href="#abc0f57ecfb581d0d310c8f0b903f1a15"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01059.html#a6d6e150a8aac3d7e807f822e59d886db">Value</a> (T *v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct initialization constructor template for non-const pointers.  <a href="#a6d6e150a8aac3d7e807f822e59d886db"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01059.html#aecef879806d16fa02bc37ccd6aa525d8">Value</a> (const T *v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct initialization constructor template for non-const pointers.  <a href="#aecef879806d16fa02bc37ccd6aa525d8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01059.html#a7d23ad49bf03cb470a70d3c009e87b5c">Value</a> (const T &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct initialization constructor template for all types that are not handled by any of the constructors above.  <a href="#a7d23ad49bf03cb470a70d3c009e87b5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#af7cec9b2b3e2c638b1c65ee7af7dd7bb">Value</a> (const <a class="el" href="a01059.html">Value</a> &amp;copy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#af7cec9b2b3e2c638b1c65ee7af7dd7bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#a71fea183833907ddd58118bdcf74e5e2">~Value</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a71fea183833907ddd58118bdcf74e5e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01059.html">Value</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#aa1cccbadd31de48d29490541f6094709">operator=</a> (const <a class="el" href="a01059.html">Value</a> &amp;copy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator. Behaves like the copy constructor.  <a href="#aa1cccbadd31de48d29490541f6094709"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#a286a31af6eb3acd1fbf710bfd55ed8c2">isTypedPointer</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the value is a pointer and it points to something whose type is different than void.  <a href="#a286a31af6eb3acd1fbf710bfd55ed8c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#a144cfa2c06b064d8c2a3a0216999971e">isEmpty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether this <a class="el" href="a01059.html">Value</a> is empty.  <a href="#a144cfa2c06b064d8c2a3a0216999971e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#a306dfd01db25a5dfed7ec33c8fbbe48f">isNullPointer</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the value is a null pointer.  <a href="#a306dfd01db25a5dfed7ec33c8fbbe48f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00945.html">Type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#a44732974c7658851cd791bc8e2f7240c">getType</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the exact type of the value held.  <a href="#a44732974c7658851cd791bc8e2f7240c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00945.html">Type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#a4a595f6f296db551615841c65acdb750">getInstanceType</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the value is a pointer to a non-void type, this method returns the actual type of the dereferenced pointer.  <a href="#a4a595f6f296db551615841c65acdb750"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#aabb6daf63204ef4a3bb444de217cc314">operator==</a> (const <a class="el" href="a01059.html">Value</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equal to operator.  <a href="#aabb6daf63204ef4a3bb444de217cc314"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#aab83c65d77a8775484626a8ac563e656">operator&lt;=</a> (const <a class="el" href="a01059.html">Value</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Less than or equal to operator.  <a href="#aab83c65d77a8775484626a8ac563e656"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#aeab57924469d560ba767908c8931dd60">operator!=</a> (const <a class="el" href="a01059.html">Value</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality test operator. Returns !operator==(other).  <a href="#aeab57924469d560ba767908c8931dd60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#a2a286d1daed86d35314c63566204de5c">operator&gt;</a> (const <a class="el" href="a01059.html">Value</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Greater than operator. Returns !operator&lt;=(other).  <a href="#a2a286d1daed86d35314c63566204de5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#ab1ef6add0a795f8ef1835724f9cf68df">operator&lt;</a> (const <a class="el" href="a01059.html">Value</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Less than operator. Returns !operator==(other) &amp;&amp; operator&lt;=(other).  <a href="#ab1ef6add0a795f8ef1835724f9cf68df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#a631b329f30ec50702f1fc9230e7f9eb1">operator&gt;=</a> (const <a class="el" href="a01059.html">Value</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Greater than or equal to operator. Returns operator==(other) || !operator&lt;=(other).  <a href="#a631b329f30ec50702f1fc9230e7f9eb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01059.html">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#ac0a0cd433dfd7091f51be41122edc3bd">convertTo</a> (const <a class="el" href="a00945.html">Type</a> &amp;outtype) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to convert this instance to a <a class="el" href="a01059.html">Value</a> of the given type.  <a href="#ac0a0cd433dfd7091f51be41122edc3bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01059.html">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#ace3a144801299497faad274df3b2ebc3">tryConvertTo</a> (const <a class="el" href="a00945.html">Type</a> &amp;outtype) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to convert this instance to a <a class="el" href="a01059.html">Value</a> of the given type.  <a href="#ace3a144801299497faad274df3b2ebc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#a14e71ef2341c5e38212a0752a666a154">toString</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to get a string representation of the underlying value.  <a href="#a14e71ef2341c5e38212a0752a666a154"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#aadb9ce7146a92ef740093896da2afbd5">toWString</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01059.html#ac3f8a051095fcd1265146435b4631c62">swap</a> (<a class="el" href="a01059.html">Value</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the content of this <a class="el" href="a01059.html">Value</a> with another <a class="el" href="a01059.html">Value</a>.  <a href="#ac3f8a051095fcd1265146435b4631c62"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01059.html#ad6bf946397d76adca9c06382c1f6949a">variant_cast</a> (const <a class="el" href="a01059.html">Value</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to convert an instance of <a class="el" href="a01059.html">Value</a> to an object of type T.  <a href="#ad6bf946397d76adca9c06382c1f6949a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01059.html#a90484c26c6303f46507d9f60235f6a77">requires_conversion</a> (const <a class="el" href="a01059.html">Value</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the <a class="el" href="a01059.html">Value</a> passed as parameter can't be casted to the specified type without a (potentially slow) conversion.  <a href="#a90484c26c6303f46507d9f60235f6a77"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01059.html#a0b4f5296d7a0a4a4ab2c7b53ac24fe83">extract_raw_data</a> (<a class="el" href="a01059.html">Value</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a typed pointer to the data contained in a <a class="el" href="a01059.html">Value</a> instance.  <a href="#a0b4f5296d7a0a4a4ab2c7b53ac24fe83"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01059.html#a15da27a6170cac2be2a33e2b3d0c0c81">extract_raw_data</a> (const <a class="el" href="a01059.html">Value</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a typed pointer to the data contained in a const <a class="el" href="a01059.html">Value</a> instance.  <a href="#a15da27a6170cac2be2a33e2b3d0c0c81"></a><br/></td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aff2070731e7ac55c677afe4fd9c69157"></a><!-- doxytag: member="osgIntrospection::Value::Value" ref="aff2070731e7ac55c677afe4fd9c69157" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osgIntrospection::Value::Value </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>Initializes internal structures so that the <a class="el" href="a00945.html" title="Objects of class Type are used to maintain information about reflected types.">Type</a> returned by <a class="el" href="a01059.html#a44732974c7658851cd791bc8e2f7240c" title="Returns the exact type of the value held.">getType()</a> is <a class="el" href="a01431.html#aee755fa032e800f112d0be8bf093edf2" title="This macro emulates the behavior of the standard typeid operator, returning the Type object associate...">typeof(void)</a>, and the value is empty so that <a class="el" href="a01059.html#a144cfa2c06b064d8c2a3a0216999971e" title="Returns whether this Value is empty.">isEmpty()</a> returns true. Be careful when using empty values, as some operations on them may throw an exception. </p>

</div>
</div>
<a class="anchor" id="a7f8f9e40565bb64d8dc3fc50d5a58041"></a><!-- doxytag: member="osgIntrospection::Value::Value" ref="a7f8f9e40565bb64d8dc3fc50d5a58041" args="(void *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osgIntrospection::Value::Value </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct initialization constructor for void pointers. </p>
<p>Although one of the constructor templates below could certainly handle void pointers as well, we need to treat them separately because void* can't be dereferenced. </p>

</div>
</div>
<a class="anchor" id="abc0f57ecfb581d0d310c8f0b903f1a15"></a><!-- doxytag: member="osgIntrospection::Value::Value" ref="abc0f57ecfb581d0d310c8f0b903f1a15" args="(const void *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osgIntrospection::Value::Value </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct initialization constructor for const void pointers. </p>
<p>Although one of the constructor templates below could certainly handle void pointers as well, we need to treat them separately because void* can't be dereferenced. </p>

</div>
</div>
<a class="anchor" id="a6d6e150a8aac3d7e807f822e59d886db"></a><!-- doxytag: member="osgIntrospection::Value::Value" ref="a6d6e150a8aac3d7e807f822e59d886db" args="(T *v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">osgIntrospection::Value::Value </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct initialization constructor template for non-const pointers. </p>
<p>By initializing an instance of <a class="el" href="a01059.html">Value</a> through this constructor, internal structures will be configured to handle polymorphic types. This means you'll be able to call <a class="el" href="a01059.html#a4a595f6f296db551615841c65acdb750" title="If the value is a pointer to a non-void type, this method returns the actual type of the dereferenced...">getInstanceType()</a> to get the actual type of the dereferenced value. </p>

</div>
</div>
<a class="anchor" id="aecef879806d16fa02bc37ccd6aa525d8"></a><!-- doxytag: member="osgIntrospection::Value::Value" ref="aecef879806d16fa02bc37ccd6aa525d8" args="(const T *v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">osgIntrospection::Value::Value </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct initialization constructor template for non-const pointers. </p>
<p>By initializing an instance of <a class="el" href="a01059.html">Value</a> through this constructor, internal structures will be configured to handle polymorphic types. This means you'll be able to call <a class="el" href="a01059.html#a4a595f6f296db551615841c65acdb750" title="If the value is a pointer to a non-void type, this method returns the actual type of the dereferenced...">getInstanceType()</a> to get the actual type of the dereferenced value. </p>

</div>
</div>
<a class="anchor" id="a7d23ad49bf03cb470a70d3c009e87b5c"></a><!-- doxytag: member="osgIntrospection::Value::Value" ref="a7d23ad49bf03cb470a70d3c009e87b5c" args="(const T &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">osgIntrospection::Value::Value </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct initialization constructor template for all types that are not handled by any of the constructors above. </p>
<p>Calling <a class="el" href="a01059.html#a4a595f6f296db551615841c65acdb750" title="If the value is a pointer to a non-void type, this method returns the actual type of the dereferenced...">getInstanceType()</a> on an instance constructed this way returns the same as <a class="el" href="a01059.html#a44732974c7658851cd791bc8e2f7240c" title="Returns the exact type of the value held.">getType()</a>. </p>

</div>
</div>
<a class="anchor" id="af7cec9b2b3e2c638b1c65ee7af7dd7bb"></a><!-- doxytag: member="osgIntrospection::Value::Value" ref="af7cec9b2b3e2c638b1c65ee7af7dd7bb" args="(const Value &amp;copy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osgIntrospection::Value::Value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01059.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>The underlying value's type must have consistent copy semantics. </p>

</div>
</div>
<a class="anchor" id="a71fea183833907ddd58118bdcf74e5e2"></a><!-- doxytag: member="osgIntrospection::Value::~Value" ref="a71fea183833907ddd58118bdcf74e5e2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osgIntrospection::Value::~Value </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Frees internal resources but it does NOT delete the value held. For example, this function will produce a memory leak: void f() { <a class="el" href="a01059.html">Value</a> v(new int); } </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac0a0cd433dfd7091f51be41122edc3bd"></a><!-- doxytag: member="osgIntrospection::Value::convertTo" ref="ac0a0cd433dfd7091f51be41122edc3bd" args="(const Type &amp;outtype) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01059.html">Value</a> osgIntrospection::Value::convertTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00945.html">Type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>outtype</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to convert this instance to a <a class="el" href="a01059.html">Value</a> of the given type. </p>
<p>The conversion is performed by rendering to a temporary stream in the source format and trying to read back from the stream in the destination format. If either the source or destination types, or both, don't have a <a class="el" href="a00618.html" title="This is the base class for reader/writer objects.">ReaderWriter</a> object, the conversion fails and an exception is thrown. If the conversion can't be completed for other reasons, other exceptions may be thrown. </p>

<p>Referenced by <a class="el" href="a01640.html#a1dc2aaf06d54c6320f0d8bf14c22d4c0">osgIntrospection::convertArgument()</a>, and <a class="el" href="a01640.html#a4ce1a25302dcf049d78761103d052752">osgIntrospection::variant_cast()</a>.</p>

</div>
</div>
<a class="anchor" id="a4a595f6f296db551615841c65acdb750"></a><!-- doxytag: member="osgIntrospection::Value::getInstanceType" ref="a4a595f6f296db551615841c65acdb750" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00945.html">Type</a> &amp; osgIntrospection::Value::getInstanceType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the value is a pointer to a non-void type, this method returns the actual type of the dereferenced pointer. </p>
<p>Please note it is not the same as <a class="el" href="a01059.html#a44732974c7658851cd791bc8e2f7240c" title="Returns the exact type of the value held.">getType()</a>.getPointedType(), because the latter would return the non-polymorphic type. If the value is not a pointer, this method behaves like <a class="el" href="a01059.html#a44732974c7658851cd791bc8e2f7240c" title="Returns the exact type of the value held.">getType()</a>. </p>

</div>
</div>
<a class="anchor" id="a44732974c7658851cd791bc8e2f7240c"></a><!-- doxytag: member="osgIntrospection::Value::getType" ref="a44732974c7658851cd791bc8e2f7240c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00945.html">Type</a> &amp; osgIntrospection::Value::getType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the exact type of the value held. </p>

<p>Referenced by <a class="el" href="a00981.html#ae1f859be15bf04e6ad5f2e0c31dcab09">osgIntrospection::TypedMethodInfo16&lt; C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15 &gt;::invoke()</a>, <a class="el" href="a00979.html#a2f95a3db8308ff4c66f204de218ce048">osgIntrospection::TypedMethodInfo15&lt; C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14 &gt;::invoke()</a>, <a class="el" href="a00977.html#a8ab4138c7199832fd6fcfed74f8d22fe">osgIntrospection::TypedMethodInfo14&lt; C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13 &gt;::invoke()</a>, <a class="el" href="a00975.html#a4398b7982c24df83da58e6d3b34651f9">osgIntrospection::TypedMethodInfo13&lt; C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12 &gt;::invoke()</a>, <a class="el" href="a00973.html#afdac3ad2de6cc3e952501b30d38d9c5b">osgIntrospection::TypedMethodInfo12&lt; C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11 &gt;::invoke()</a>, <a class="el" href="a00971.html#aca2075acb64b4a289f6adb3bb372e019">osgIntrospection::TypedMethodInfo11&lt; C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10 &gt;::invoke()</a>, <a class="el" href="a00969.html#a3962b514a78f08471113c2bc708eae76">osgIntrospection::TypedMethodInfo10&lt; C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9 &gt;::invoke()</a>, <a class="el" href="a00998.html#aca359ceabf028165bd4a295ff19f39d7">osgIntrospection::TypedMethodInfo9&lt; C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8 &gt;::invoke()</a>, <a class="el" href="a00996.html#abfa829d0c4431c54a61176fee76f8132">osgIntrospection::TypedMethodInfo8&lt; C, void, P0, P1, P2, P3, P4, P5, P6, P7 &gt;::invoke()</a>, <a class="el" href="a00994.html#a38883c394e846a173b0a989b3c531cc4">osgIntrospection::TypedMethodInfo7&lt; C, void, P0, P1, P2, P3, P4, P5, P6 &gt;::invoke()</a>, <a class="el" href="a00992.html#a0b4c43ed33405207f431a2b71b849c0c">osgIntrospection::TypedMethodInfo6&lt; C, void, P0, P1, P2, P3, P4, P5 &gt;::invoke()</a>, <a class="el" href="a00990.html#a33b184efe5ce150b419329118010e017">osgIntrospection::TypedMethodInfo5&lt; C, void, P0, P1, P2, P3, P4 &gt;::invoke()</a>, <a class="el" href="a00988.html#a6265310ed1276cbbd54be163e994794f">osgIntrospection::TypedMethodInfo4&lt; C, void, P0, P1, P2, P3 &gt;::invoke()</a>, <a class="el" href="a00986.html#af6693c0fc27aa07a7c0bba3f69df190e">osgIntrospection::TypedMethodInfo3&lt; C, void, P0, P1, P2 &gt;::invoke()</a>, <a class="el" href="a00984.html#a42abdf05b3d90bd105b84b3546216bee">osgIntrospection::TypedMethodInfo2&lt; C, void, P0, P1 &gt;::invoke()</a>, <a class="el" href="a00982.html#a48370a404044ac615d1d639abe09126a">osgIntrospection::TypedMethodInfo1&lt; C, void, P0 &gt;::invoke()</a>, <a class="el" href="a00966.html#ad06dbc8a02a2331363e9db444477bd57">osgIntrospection::TypedMethodInfo0&lt; C, void &gt;::invoke()</a>, <a class="el" href="a00980.html#a1bcae5bd9b501a465133806e1499ac99">osgIntrospection::TypedMethodInfo16&lt; C, R, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15 &gt;::invoke()</a>, <a class="el" href="a00978.html#a73f4b09146d18740e81bea5a06160c2b">osgIntrospection::TypedMethodInfo15&lt; C, R, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14 &gt;::invoke()</a>, <a class="el" href="a00976.html#a5f8c375dbb9989a75e373c192e6b5d54">osgIntrospection::TypedMethodInfo14&lt; C, R, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13 &gt;::invoke()</a>, <a class="el" href="a00974.html#a573ba717c1b98cfd015bf95694710e35">osgIntrospection::TypedMethodInfo13&lt; C, R, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12 &gt;::invoke()</a>, <a class="el" href="a00972.html#a2d61995824fe6a1ab264ca2d88be4c3f">osgIntrospection::TypedMethodInfo12&lt; C, R, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11 &gt;::invoke()</a>, <a class="el" href="a00970.html#a1eab1b2dcb77e5bd6ac3691b23381299">osgIntrospection::TypedMethodInfo11&lt; C, R, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10 &gt;::invoke()</a>, <a class="el" href="a00968.html#a6793c353852c7e68abcebbdc717ac359">osgIntrospection::TypedMethodInfo10&lt; C, R, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9 &gt;::invoke()</a>, <a class="el" href="a00997.html#a2316bf5e3106a845dc74fcca6ec0c54f">osgIntrospection::TypedMethodInfo9&lt; C, R, P0, P1, P2, P3, P4, P5, P6, P7, P8 &gt;::invoke()</a>, <a class="el" href="a00995.html#a1b35f1175501bef9e89d1628853055e9">osgIntrospection::TypedMethodInfo8&lt; C, R, P0, P1, P2, P3, P4, P5, P6, P7 &gt;::invoke()</a>, <a class="el" href="a00993.html#aeeab3ac8049a24f9b27369d9915b4a0c">osgIntrospection::TypedMethodInfo7&lt; C, R, P0, P1, P2, P3, P4, P5, P6 &gt;::invoke()</a>, <a class="el" href="a00991.html#acd71bfeff22bb5eed2c85c8ad69e1b06">osgIntrospection::TypedMethodInfo6&lt; C, R, P0, P1, P2, P3, P4, P5 &gt;::invoke()</a>, <a class="el" href="a00989.html#a846ad71a766371ec9bd04db3e20a7747">osgIntrospection::TypedMethodInfo5&lt; C, R, P0, P1, P2, P3, P4 &gt;::invoke()</a>, <a class="el" href="a00987.html#a392f580bf9c8511f3761d7de643948fe">osgIntrospection::TypedMethodInfo4&lt; C, R, P0, P1, P2, P3 &gt;::invoke()</a>, <a class="el" href="a00985.html#a00e5c449698f37df125ede30933bcdeb">osgIntrospection::TypedMethodInfo3&lt; C, R, P0, P1, P2 &gt;::invoke()</a>, <a class="el" href="a00983.html#a8fe7a66b3c314375dfeb383a383fdc4a">osgIntrospection::TypedMethodInfo2&lt; C, R, P0, P1 &gt;::invoke()</a>, <a class="el" href="a00967.html#a52c84d939062718e164d74ac82dbfeac">osgIntrospection::TypedMethodInfo1&lt; C, R, P0 &gt;::invoke()</a>, <a class="el" href="a00965.html#aa3f680a5b8328687f2ec2ada3efd6326">osgIntrospection::TypedMethodInfo0&lt; C, R &gt;::invoke()</a>, <a class="el" href="a00618.html#ac5b1057efd1c76eb4cc04b37eab6d43f">osgIntrospection::ReaderWriter::readBinaryValue()</a>, <a class="el" href="a00618.html#afe17eb49439aaed422d448eccc0ed342">osgIntrospection::ReaderWriter::readTextValue()</a>, <a class="el" href="a00618.html#a2533cdcaabb12c3a4936eb359e3d8845">osgIntrospection::ReaderWriter::writeBinaryValue()</a>, and <a class="el" href="a00618.html#a8a0102d234a3f03cc866b5bc1c4ea7c4">osgIntrospection::ReaderWriter::writeTextValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a144cfa2c06b064d8c2a3a0216999971e"></a><!-- doxytag: member="osgIntrospection::Value::isEmpty" ref="a144cfa2c06b064d8c2a3a0216999971e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osgIntrospection::Value::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether this <a class="el" href="a01059.html">Value</a> is empty. </p>

<p>Referenced by <a class="el" href="a00834.html#a2d0e554293626e425192031d40fec139">osgIntrospection::StdWReaderWriter&lt; T &gt;::readBinaryValue()</a>, <a class="el" href="a00831.html#a0d7693ad1f0aa1c9a8b9d166cccc7139">osgIntrospection::StdReaderWriter&lt; T &gt;::readBinaryValue()</a>, <a class="el" href="a00834.html#a8a32eee979bddec53e6d8d12cd51b119">osgIntrospection::StdWReaderWriter&lt; T &gt;::readTextValue()</a>, and <a class="el" href="a00831.html#a23d48306f1845e7fdf88422b5ceabd97">osgIntrospection::StdReaderWriter&lt; T &gt;::readTextValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a306dfd01db25a5dfed7ec33c8fbbe48f"></a><!-- doxytag: member="osgIntrospection::Value::isNullPointer" ref="a306dfd01db25a5dfed7ec33c8fbbe48f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osgIntrospection::Value::isNullPointer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the value is a null pointer. </p>

</div>
</div>
<a class="anchor" id="a286a31af6eb3acd1fbf710bfd55ed8c2"></a><!-- doxytag: member="osgIntrospection::Value::isTypedPointer" ref="a286a31af6eb3acd1fbf710bfd55ed8c2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osgIntrospection::Value::isTypedPointer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the value is a pointer and it points to something whose type is different than void. </p>

<p>Referenced by <a class="el" href="a01640.html#a73c23564bada31d1698c71334c907adf">osgIntrospection::getInstance()</a>.</p>

</div>
</div>
<a class="anchor" id="aeab57924469d560ba767908c8931dd60"></a><!-- doxytag: member="osgIntrospection::Value::operator!=" ref="aeab57924469d560ba767908c8931dd60" args="(const Value &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osgIntrospection::Value::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01059.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inequality test operator. Returns !operator==(other). </p>

</div>
</div>
<a class="anchor" id="ab1ef6add0a795f8ef1835724f9cf68df"></a><!-- doxytag: member="osgIntrospection::Value::operator&lt;" ref="ab1ef6add0a795f8ef1835724f9cf68df" args="(const Value &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osgIntrospection::Value::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01059.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Less than operator. Returns !operator==(other) &amp;&amp; operator&lt;=(other). </p>

</div>
</div>
<a class="anchor" id="aab83c65d77a8775484626a8ac563e656"></a><!-- doxytag: member="osgIntrospection::Value::operator&lt;=" ref="aab83c65d77a8775484626a8ac563e656" args="(const Value &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osgIntrospection::Value::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01059.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Less than or equal to operator. </p>

</div>
</div>
<a class="anchor" id="aa1cccbadd31de48d29490541f6094709"></a><!-- doxytag: member="osgIntrospection::Value::operator=" ref="aa1cccbadd31de48d29490541f6094709" args="(const Value &amp;copy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01059.html">Value</a> &amp; osgIntrospection::Value::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01059.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. Behaves like the copy constructor. </p>

</div>
</div>
<a class="anchor" id="aabb6daf63204ef4a3bb444de217cc314"></a><!-- doxytag: member="osgIntrospection::Value::operator==" ref="aabb6daf63204ef4a3bb444de217cc314" args="(const Value &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osgIntrospection::Value::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01059.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equal to operator. </p>

</div>
</div>
<a class="anchor" id="a2a286d1daed86d35314c63566204de5c"></a><!-- doxytag: member="osgIntrospection::Value::operator&gt;" ref="a2a286d1daed86d35314c63566204de5c" args="(const Value &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osgIntrospection::Value::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01059.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Greater than operator. Returns !operator&lt;=(other). </p>

</div>
</div>
<a class="anchor" id="a631b329f30ec50702f1fc9230e7f9eb1"></a><!-- doxytag: member="osgIntrospection::Value::operator&gt;=" ref="a631b329f30ec50702f1fc9230e7f9eb1" args="(const Value &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osgIntrospection::Value::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01059.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Greater than or equal to operator. Returns operator==(other) || !operator&lt;=(other). </p>

</div>
</div>
<a class="anchor" id="ac3f8a051095fcd1265146435b4631c62"></a><!-- doxytag: member="osgIntrospection::Value::swap" ref="ac3f8a051095fcd1265146435b4631c62" args="(Value &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osgIntrospection::Value::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01059.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the content of this <a class="el" href="a01059.html">Value</a> with another <a class="el" href="a01059.html">Value</a>. </p>

<p>Referenced by <a class="el" href="a01640.html#a1dc2aaf06d54c6320f0d8bf14c22d4c0">osgIntrospection::convertArgument()</a>.</p>

</div>
</div>
<a class="anchor" id="a14e71ef2341c5e38212a0752a666a154"></a><!-- doxytag: member="osgIntrospection::Value::toString" ref="a14e71ef2341c5e38212a0752a666a154" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string osgIntrospection::Value::toString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to get a string representation of the underlying value. </p>
<p>This requires the value's type to have a <a class="el" href="a00618.html" title="This is the base class for reader/writer objects.">ReaderWriter</a> object associated to it. If the conversion can't be completed, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="aadb9ce7146a92ef740093896da2afbd5"></a><!-- doxytag: member="osgIntrospection::Value::toWString" ref="aadb9ce7146a92ef740093896da2afbd5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring osgIntrospection::Value::toWString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ace3a144801299497faad274df3b2ebc3"></a><!-- doxytag: member="osgIntrospection::Value::tryConvertTo" ref="ace3a144801299497faad274df3b2ebc3" args="(const Type &amp;outtype) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01059.html">Value</a> osgIntrospection::Value::tryConvertTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00945.html">Type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>outtype</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to convert this instance to a <a class="el" href="a01059.html">Value</a> of the given type. </p>
<p>The conversion is performed by rendering to a temporary stream in the source format and trying to read back from the stream in the destination format. If either the source or destination types, or both, don't have a <a class="el" href="a00618.html" title="This is the base class for reader/writer objects.">ReaderWriter</a> object, the conversion fails and an empty <a class="el" href="a01059.html">Value</a> is returned. Please note that unlike <a class="el" href="a01059.html#ac0a0cd433dfd7091f51be41122edc3bd" title="Tries to convert this instance to a Value of the given type.">convertTo()</a>, this method does not intentionally throw any exceptions. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a0b4f5296d7a0a4a4ab2c7b53ac24fe83"></a><!-- doxytag: member="osgIntrospection::Value::extract_raw_data" ref="a0b4f5296d7a0a4a4ab2c7b53ac24fe83" args="(Value &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* extract_raw_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01059.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a typed pointer to the data contained in a <a class="el" href="a01059.html">Value</a> instance. </p>
<p>If the value's type is not identical to type T, a null pointer is returned. </p>

</div>
</div>
<a class="anchor" id="a15da27a6170cac2be2a33e2b3d0c0c81"></a><!-- doxytag: member="osgIntrospection::Value::extract_raw_data" ref="a15da27a6170cac2be2a33e2b3d0c0c81" args="(const Value &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* extract_raw_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01059.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a typed pointer to the data contained in a const <a class="el" href="a01059.html">Value</a> instance. </p>
<p>If the value's type is not identical to type T, a null pointer is returned. </p>

</div>
</div>
<a class="anchor" id="a90484c26c6303f46507d9f60235f6a77"></a><!-- doxytag: member="osgIntrospection::Value::requires_conversion" ref="a90484c26c6303f46507d9f60235f6a77" args="(const Value &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool requires_conversion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01059.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the <a class="el" href="a01059.html">Value</a> passed as parameter can't be casted to the specified type without a (potentially slow) conversion. </p>
<p>Returns false otherwise. </p>

</div>
</div>
<a class="anchor" id="ad6bf946397d76adca9c06382c1f6949a"></a><!-- doxytag: member="osgIntrospection::Value::variant_cast" ref="ad6bf946397d76adca9c06382c1f6949a" args="(const Value &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T variant_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01059.html">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to convert an instance of <a class="el" href="a01059.html">Value</a> to an object of type T. </p>
<p>If T is a plain type or a pointer type (either const or non-const), and it matches the type of the value contained in v, then the actual value of type T is returned. If T is a [const] reference type, and its base (non reference) type matches the internal value's type, then a [const] reference to the internal value is returned. If none of the above conditions are met, a conversion is attempted as described in Value::convert() and then variant_cast is called again with the converted value as parameter. If the conversion can't be completed, an exception is thrown. Conversions that attempt to make a const pointer non-const will fail. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>osgIntrospection/<a class="el" href="a01441.html">Value</a></li>
</ul>
</div>
<hr>
<table border="0"><tr><td>
  <img src="osg32-32.png" alt="osg logo" />
</td><td>
  <address><small>Generated at Thu Jun 9 2011 16:37:16 for the <a href="http://www.openscenegraph.org/">OpenSceneGraph</a>
by <a href="http://www.doxygen.org">doxygen</a> 1.7.1.</small></address>
<!-- Dimitri van Heesch's e-mail address removed, lest he get messages on the OpenSceneGraph -->
</td></tr></table>
</body>
</html>
